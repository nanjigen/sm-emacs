#+BRAIN_PARENTS: system
#+TITLE: sm-emacs
#+auto_tangle: nil

A package for the management of Supermemo under Wine - interfaced via Emacs.

Features:

- Emacs integration by the following means:
  + Emacs and EXWM X-window/buffer management
    - Reliable named buffers navigate-able through EXWM
    - =display-buffer-alist= rules for SM windows; allowing for declarative window arrangement
    - ~Burly~ bookmarking of SM views
  + Text-streams via =exwm-input--fake-key= (utilizing ~Autohotkey~ as a backend) allowing for:
    - vIM-style modal bindings with NORMAL and Insert modes (EXWM).
    - Access to SM interface options as hydra-menus.
    - Item element editing in org buffers, with all markup converted back to HTML.
  + *Incremental video via mpv*, *org-media-protocol* and *org-protocol* links, allowing for:
    - ~lua~ and ~elisp~ based generation of gifs, extractions of subs, etc.
    - Link based extraction of time-stamps
    - Note-taking with ~org-mode~, scheduling with SM
  + *Incremental reading of PDFs* via ~org-noter~ and ~pdftools~

- Bridging functions between SMA, SM, and Emacs creating possibilities for:
  + Emacs completion-style fuzzy lookup of elements based on their element-id
  + Org-mode card building, much like [[https://github.com/louietan/anki-editor][anki-editor]]

** PROJECT separate out sm-config and sm-package                   :@computer:
*** NEXT clean up sm-emacs org file
:PROPERTIES:
:TRIGGER:  chain-find-next(NEXT,from-current,priority-up,effort-down)
:END:
*** TODO clean up sm-config file
*** TODO commit develop sm-emacs

** TODO Add note about font and SM to config
:PROPERTIES:
:CREATED:  [2022-06-28 Tue 08:43]
:ID:       3acae88a-3588-4b68-90e2-6f882dd4fe5a
:END:

Use the gothic font for SM's UI for a much faster screen refresh
#+begin_src elisp
(setq sm-emacs-cjk-fonts-dir "/.local/fonts")
#+end_src

** TODO figure out how to merge 2 pics with imagemagick     :@phone:@computer:
:PROPERTIES:
:CREATED:  [2022-06-28 Tue 08:43]
:ID:       253f8020-2355-450d-a7a4-021369de84f9
:END:

** TODO search and replace 尾高 and 平板

- [ ] in org files
- [ ] in sm collection

* Overview

* Setup SM window management
:PROPERTIES:
:CREATED:  [2020-10-09 Fri 18:15]
:ID:       5f96c370-eb26-4117-a7d8-43793e465c9d
:END:

By identifying and naming different SuperMemo window buffers, we can have a reliable way to target those buffers with text streams. Specifically, we can target a buffer with a simulated keypress, affording us a kind of poor-man's API by way of scripting window movement and key-chords in an orchistrated way.

** Capturing buffers
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 10:39]
:ID:       8cf89b9a-bdb4-41a4-a3a9-4343be5c0ee6
:END:

A quirk of using SM under Wine is that a virtual desktop steals management of SM's windows and X naming scheme. In order to use text-streaming and window/buffer management with ~EXWM~ we want to be able to target named instances of the windows which will means we'll need to capture the buffer via =WM_TITLE= of individual windows.

We want to capture the following buffer titles with a regex so that we can move:
a. The Knowledge tree to the left of the screen.
b. The tray to the bottom, but not spanning the whole width of the screen.
c. Have the review buffer as the main window.
d. Have all other SM related windows as floating frames centered on the screen.

We'll use [[info:elisp#Rx][rx]] to handle the notation.

Example of the kinds of text we'll need to capture:
#+begin_example:
Topic #10:
Element #9:
OR
Element
sm18.exe/Second Language
#+end_example:

We can test if our regex captures a given buffer:

#+begin_src elisp :noweb yes
;;TODO use `cl-loop' here instead with its buffer spec
(seq-filter (lambda (buf)
              (string-match-p
               <<element-window-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

** Key SuperMemo windows
:PROPERTIES:
:CREATED:  [2021-09-23 Thu 13:15]
:ID:       523441d5-46f3-45e4-9900-c9ce786dd9f7
:END:

We'll start with the outlier first as its the most important window. Normally, SuperMemo will start with the first scheduled item of the day loaded into the elements window. The element name bleeds into the =WM_TITLE= variable and since we can't predict which element would be presented first on any given day, we will have to use a work around to get a stable title.

The following makes use of Supermemo's ability to set a constant element via the bla bla menu. While this was originally intended to display quotes or the like it works nicely for us as the same text will be shown via =WM_TITLE= and by extension by in the =exwm-title= variable.
Besides, Emacs can be rigged to have this kind of functionality at startup and perform it even better.

Here I use =home= as the only text in the element body, but you can use whatever you like. I've written the hooks in such a way that the buffer-name will remain constant even after progressing past this initial home element.

#+name: element-window-rx
#+begin_src elisp
(rx bol "home" eol)
#+end_src

#+RESULTS: element-window-rx
: ^home$

#+NAME: element-data-rx
#+begin_src elisp
(rx
 (|
  (seq (or "Topic" "Element") space "#" (one-or-more digit) ":")
  (seq "Element data")))
#+end_src

Next capture the knowledge tree:
"X:sm18.exe/neuron"
#+NAME: knowledge-tree-rx
#+begin_src elisp
(rx bol "neuron" eol)
#+end_src

#+RESULTS: knowledge-tree-rx
: ^neuron$

We'll also attempt to suppress the empty(?) buffer created by Supermemo.
This seems to be a frame made for SM.
#+NAME: empty-sm-frame-rx
#+begin_src elisp
(regexp-quote "z:\\home\\nanjigen\\documents\\sm")
#+end_src

#+RESULTS: empty-sm-frame-rx
: z:\\home\\vrika\\documents\\sm

Now we'll throw this together as a set of buffer rules:

** Creating the =sm18.exe= class
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 10:39]
:ID:       c0a59157-a741-4824-b25e-4b8cab63a2d9
:END:

The catch-all [[file:funcs.el::defun exwm/rename-buffer (][exwm/rename-buffer]] function captures the sm buffers on each update of the =title-hook=. We need to exclude members of the =sm18.exe= class from this over-general hook:

Exclusion from the generic =exwm/rename-buffer= function based on =exwm-class=:
#+begin_src elisp :noweb yes :noweb-ref exwm-title-hook
(add-hook 'exwm-update-title-hook
          (defun my-exwm-update-title-hook ()
            (unless (or (string-prefix-p "sm18.exe" exwm-class-name))
              (exwm/rename-buffer))))

#+end_src

However, currently the [[file:~/.local/share/applications/supermemo18.supermemo18.desktop::StartupWMClass=sm18.exe][StartupWMClass]] for sm18 is not propagating out to the actuall WM_CLASS as =sm18.exe=, possibly as a limitation of =wine-5.2= (actually, the =.desktop= entry doesn't work for me at all).

The below now works by hooking into the stable =exwm-instance-name=

#+begin_src elisp :noweb yes :noweb-ref exwm-class-hook
(add-hook 'exwm-update-class-hook
          (defun rename-sm-class ()
            "Rename sm18.exe class"
            (when (string-match (rx "sm18.exe") exwm-instance-name)
              (setq exwm-class-name exwm-instance-name))))

(add-hook 'exwm-update-class-hook
          (defun my-exwm-update-class-hook ()
            (unless (or (string-prefix-p "sm18.exe" exwm-class-name))
              (exwm/rename-buffer))))

#+end_src

** TODO get-buffer-create for sm windows?
** TODO don't resize sm buffers
** Regex and buffer alists
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       fe2492e4-5d72-481b-8c9b-2b8358055ea7
:END:

A cleaner approach than multiple ~when~ statements is to store the target =buffer-name= and =exwm-title= regex's as key . value pairs, respectively [fn:1].

I should probably be writing this as =cons= and not using backquotes.
#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(setq sm-exwm-core-buffer-alist
      (list `("sm-element-window" . ,<<element-window-rx>>)
            `("sm-knowledge-tree" . ,<<knowledge-tree-rx>>)
            '("sm-template-registry" . "Template Registry")
            `("sm-element-data" . ,
               <<element-data-rx>>)
            `("sm-frame" . ,<<empty-sm-frame-rx>>)))

#+end_src

#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(add-hook 'exwm-update-title-hook
          (defun sm-core-window-title-hook ()
            "Manage the core names"
            (cl-loop for (key . value) in sm-exwm-core-buffer-alist
                     if (string-match value exwm-title)
                     do (exwm-workspace-rename-buffer key)
                        (setq exwm-title key))))

#+end_src

#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(setq sm-exwm-floating-buffer-alist
      '(("sm-algo-choice" . "Choices")
        ("sm-backup-copy" . "Copying")
        ("sm-background" . "Back")
        ("sm-commander" . "SuperMemo Commander")
        ("sm-color-options" . "色")
        ("sm-concepts" . "Concepts")
        ("sm-edit-reference" . "Editing references")
        ("sm-element-finder" . "Find elements")
        ("sm-element-number-window" . "Element number")
        ("sm-error-window" . "Error!")
        ("sm-fonts-window" . "Font")
        ("sm-filter-window" . "^Filtering")
        ("sm-image-registry" . "Image registry")
        ("sm-images" . "Images")
        ("sm-info-window" . "Information")
        ("sm-integrity-check" . "Checking the integrity of the collection")
        ("sm-edit-reference" . "Editing references")
        ("sm-interval" . "Interval")
        ("sm-leech-window" . "Leech")
        ("sm-mercy-parameters" . "^Mercy")
        ("sm-memory-status" . "Memory status for Item")
        ("sm-modify-priority" . "Element Priority")
        ("sm-modify-priority" . "Modify Priorities")
        ("sm-neural-que" . "Element's neural que")
        ("sm-new-concept" . "New Concept")
        ("sm-open-link" . "^Open")
        ("sm-options-window" . "Options")
        ("sm-outstanding" . "Outstanding")
        ("sm-property-window" . "\%sのプロパティ")
        ("sm-question-window" . "^Question$")
        ("sm-repair-options" . "Repair Options")
        ("sm-schedule-plan" . "Schedule plan")
        ("sm-shift-input" . "Input number")
        ("sm-sorting-criteria" . "Repetition sorting criteria")
        ("sm-sound-registry" . "Sound registry")
        ("sm-sound-files" . "Sound files")
        ("sm-statistics" . "Analysis")
        ("sm-stylesheet" . "Supermemo Stylesheet")
        ("sm-text-files" . "Text files")
        ("sm-subset" . "Subset")
        ("sm-template-registry" . "Template Registry")
        ("sm-workload-calendar" . "Workload")))

#+end_src

** TODO write a function to write out names of SM windows not in alist

#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(add-hook 'exwm-update-title-hook
          (defun sm-window-title-hook ()
            "Iterate over naming alist and rename `exwm-title' to key"
            (cl-loop for (key . value) in sm-exwm-floating-buffer-alist
                     if (string-match (regexp-quote value) exwm-title)
                     do (exwm-workspace-rename-buffer key)
                        (setq exwm-title key))))

#+end_src

[fn:1] I can't find a reason to avoid the small amount of hardcoding done here. The fine-grained control outweighs any convenience automating naming would bring (as it would introduce unpredicability in the buffer naming).

Here we loop over the predefined buffer names in =sm-exwm-window-names=, adding them iteratively to =exwm-manage-configurations=. The two different loops are to differentiate floating vs non-floating windows:

#+begin_src elisp :noweb yes :noweb-ref sm managed configurations
;; (setq exwm-manage-configurations nil)
;; (add-to-list 'exwm-manage-configurations '((string= exwm-instance-name "sm18-core") managed t floating nil))
(add-to-list 'exwm-manage-configurations '((string= exwm-class-name "sm18.exe") managed t floating nil))

(cl-loop for (key . value) in sm-exwm-core-buffer-alist
         do (push `((string= exwm-title ,key) managed t floating nil) exwm-manage-configurations))

(cl-loop for (key . value) in sm-exwm-floating-buffer-alist
         do (push `((string= exwm-title ,key) managed t floating t) exwm-manage-configurations))

(add-to-list 'exwm-manage-configurations '((string= exwm-class-name "notepad.exe") managed t floating nil))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref window assignments :results silent
(require 'subr-x)  ;; Because of when-let

(defvar exwm-workspace-window-assignments
  '(("sm-element-window" . 3)
    ("sm-knowledge-tree" . 3)
    ("sm-element-data" . 3))
  "An alist of window classes and which workspace to put them on.")

(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when-let ((target (cdr (assoc exwm-class-name exwm-workspace-window-assignments))))
              (exwm-workspace-move-window target))))
#+end_src

** display-buffer-alist
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:31]
:ID:       6b6b8247-b27b-4771-bd30-74ec4653f123
:header-args: :noweb-ref buffer alist hooks
:END:

Once have these tested and working, theoretically as x-windows under EXWM are just emacs buffers, they could be controlled with the built-in ~display-buffer~ tooling via ~display-buffer-alist~:

#+begin_src elisp :tangle no :noweb no
;; (add-to-list 'display-buffer-alist
;;              `((,<<empty-sm>>
;;                 (display-buffer-no-window))
;;                (,<<tree-rx>>
;;                 (display-buffer-reuse-window display-buffer-in-side-window)
;;                 (side . left)
;;                 (slot . 0)
;;                 (window-width . 0.22))
;;                (,<<element-data-rx>>
;;                 (display-buffer-at-bottom)
;;                 ;; (side . bottom)
;;                 ;; (slot . 0)
;;                 (window-height . 0.19))))
#+end_src

However, this doesn't work as expected and we have to wrap these rules in an exwm hook:
#+begin_src elisp :noweb yes :results silent
(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when (string-match-p "sm-frame" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-frame")
               '((display-buffer-no-window)
                 (allow-no-window . t))))
            (when (string-match-p "sm-element-window" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-element-window")
               (doom-modeline-mode 1)
               '((display-buffer-same-window) ;;FIXME maybe as race condition this doesn't work as expected
                 (window-height . 0.60))))
            (when (string-match-p "sm-knowledge-tree" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-knowledge-tree")
               '((display-buffer-in-side-window)
                 ;; (inhibit-same-window . t)
                 (side . left)
                 (slot . 0)
                 (window-width . 0.21))))
            (when (string-match-p "sm-element-data" (buffer-name))
              (progn (exwm-layout-hide-mode-line)
                     (display-buffer
                      (get-buffer-create "sm-element-data")
                      '((display-buffer-in-side-window)
                        ;; (inhibit-same-window . t)
                        (side . bottom)
                        (slot . 1)
                        (window-height . 0.26)))))))
#+end_src

#+begin_src elisp :tangle no :noweb no :results silent
;; (remove-hook 'exwm-manage-finish-hook
;;           (lambda ()
;;             (when (string-match-p
;;                    <<element-data-rx>>
;;                    (buffer-name))
;;               (display-buffer-in-side-window (current-buffer)
;;                                              '((side . bottom)
;;                                                (slot . 0)
;;                                                (window-width . 0.23))))))
#+end_src

** sm-exwm-window-rules.el
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       bef0674e-a594-442b-a959-c7005f24a4d4
:END:

#+begin_src elisp :noweb yes :tangle sm-exwm-window-window-rules.el
;;; sm-exwm-window-rules.el -*- lexical-binding: t; -*-

<<exwm-class-hook>>

<<sm-window hooks>>

<<sm managed configurations>>

<<exwm-title-hook>>

<<buffer alist hooks>>
#+end_src

* sm-exwm-core
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 15:55]
:ID:       b98cd336-e48d-4a92-9998-bd88a20b1d12
:END:

Here we'll define the core keypress events we'd want to send to Supermemo.

** TODO xdotool keypress faking
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:53]
:ID:       ace7c6f8-9504-4596-a159-a4436e5d1147
:END:

#+begin_src elisp
(defun sm-exwm-xdotool-send-key (keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress)
        (window-id exwm--id))
        (shell-command
         (format "xdotool key --window %s --delay 220 %s" window-id key))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref xdotool-send
(defun sm-exwm-xdotool-send-key (mod-key keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress)
        ;; (window-id exwm--id)
        (modifier mod-key))
    (shell-command
     (format "xdotool keydown %s sleep 0.1" modifier))
    (exwm-input--fake-key key)
    (shell-command
     (format "xdotool keyup %s"  modifier))))
#+end_src

#+begin_src elisp
(defun sm-exwm-core-word ()
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'right))
#+end_src

#+begin_src elisp
(defun sm-exwm-xdotool-send-key (keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress)
        (window-id exwm--id))
    (start-process-shell-command
     "xdotool"
     "*xdotool*"
     (format "xdotool key --window %s --delay 220 %s" window-id key))))
#+end_src

Using ~shell-command-to-string~
The delay here is quiet noticeable
#+begin_src elisp :noweb yes :noweb-ref shell-command xdo
(defun sm-exwm-xdotool-send-key (keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress))
        (exwm/enter-char-mode)
        (exwm/enter-char-mode)
        ;; (while exwm-input-line-mode-passthrough
        ;;   (exwm/enter-char-mode))
        (shell-command-to-string (format "xdotool key --delay 220 %s" key))
        (exwm/enter-normal-state)))
#+end_src

Using ~make-process~
#+begin_src elisp :noweb yes :noweb-ref make-proc xdo
(defun sm-exwm-xdotool-send-key (keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress))
        (exwm/enter-char-mode)
        ;; (while exwm-input-line-mode-passthrough
        ;;   (exwm/enter-char-mode))
        (make-process
         :name "xdotool"
         ;; :buffer (current-buffer)
         :command '("xdotool" "key --delay 200 %s" key)
        (exwm/enter-normal-state))))
#+end_src

#+begin_src elisp
(defun sm-exwm-xdotool-send-string (string-text)
  "Send text-string to buffer via xdotool."
  (interactive)
  (let ((text string-text)
        (window-id exwm--id))
        (shell-command
         (format "xdotool type --window %s --delay 220 %s" window-id text))))
#+end_src

** HACK Emulating mouse events
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       f95049ad-539c-47d0-9b7e-b185593ff9eb
:END:

Before moving on to the rest of core, we need to emulate mouse button presses when in ~line-mode~
#+begin_src elisp :noweb yes :noweb-ref mouse input simulation
(defun exwm-input--on-ButtonPress-line-mode (buffer button-event)
  "Handle button events in line mode.
BUFFER is the `exwm-mode' buffer the event was generated
on. BUTTON-EVENT is the X event converted into an Emacs event.

The return value is used as event_mode to release the original
button event."
  (with-current-buffer buffer
    (let ((read-event (exwm-input--mimic-read-event button-event)))
      (exwm--log "%s" read-event)
      (if (and read-event
               (exwm-input--event-passthrough-p read-event))
          ;; The event should be forwarded to emacs
          (progn
            (exwm-input--cache-event read-event)
            (exwm-input--unread-event button-event)

            xcb:Allow:ReplayPointer)
        ;; The event should be replayed
        xcb:Allow:ReplayPointer))))
#+end_src

** Basic movement functions
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:53]
:ID:       08f4795c-fb26-4b13-8a48-99a03d67cb53
:END:

#+begin_src elisp :noweb yes :tangle sm-exwm-core.el
;;; desktop/exwm/+sm-exwm-evil.el -*- lexical-binding: t; -*-

(require 'exwm)
(require 'exwm-input)

<<xdotool-send>>

<<mouse input simulation>>

;;; Basic navigation
;;;###autoload
(defun sm-exwm-core-up ()
  "Move up."
  (interactive)
  (exwm-input--fake-key 'up))

;;;###autoload
(defun sm-exwm-core-down ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'down))

;;;###autoload
(defun sm-exwm-core-left ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'left))

;;;###autoload
(defun sm-exwm-core-right ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'right))

;;;###autoload
(defun sm-exwm-core-word ()
  "Word noun"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'right))

;;;###autoload
(defun sm-exwm-core-word-back ()
  "Back word"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'left))

;;;###autoload
(defun sm-exwm-core-beginning-of-line ()
  "Go to line start"
  (interactive)
  (exwm-input--fake-key 'home))

;;;###autoload
(defun sm-exwm-core-end-of-line ()
  "Go to line end"
  (interactive)
  (exwm-input--fake-key 'end))

;;;###autoload
(defun sm-exwm-core-goto-parent ()
  "Go to parent of current element"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'up))

;;;###autoload
(defun sm-exwm-core-goto-child ()
  "Go to the first child of current element"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'down))

;;;###autoload
(defun sm-exwm-core-forward ()
  "Go forward element"
  (interactive)
  (sm-exwm-xdotool-send-key "alt" 'right))

;;;###autoload
(defun sm-exwm-core-back ()
  "Go back element"
  (interactive)
  (sm-exwm-xdotool-send-key "alt" 'left))

;;;###autoload
(defun sm-exwm-core-goto-first-line ()
  "Go to top of component page"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'home))

;;;###autoload
(defun sm-exwm-core-goto-last-line ()
  "Go to bottom of component page
Note that this goes past the references"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'end))

;;;###autoload
(defun sm-exwm-core-scroll-up ()
  "Scroll up"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl+End"))

;;;###autoload
(defun sm-exwm-core-scroll-down ()
  "Scroll Down"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl+End"))

;;;###autoload
(defun sm-exwm-core-scroll-page-up ()
  "Scroll up by page length"
  (interactive)
  (sm-exwm-xdotool-send-key "Page_Up"))

;;;###autoload
(defun sm-exwm-core-scroll-line-down ()
  "Scroll one visual line down"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl+End"))

;;;###autoload
(defun sm-exwm-core-scroll-page-down ()
  "Scroll down by page length"
  (interactive)
  (sm-exwm-xdotool-send-key "Page_Down"))

;;;###autoload
(defun sm-exwm-core-scroll-line-up ()
  "Scroll one visual line up"
  (interactive)
  (sm-exwm-xdotool-send-key "Page_Down"))
#+end_src

#+begin_src elisp :tangle no
(add-to-list
 'display-buffer-alist
  '("\\*Async Shell Command\\*"
     (display-buffer-no-window)
     (allow-no-window . t)))

(add-to-list
 'display-buffer-alist
  '("\\*EXWM\\*"
     (display-buffer-no-window)
     (allow-no-window . t)))
#+end_src

** Selection
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:45]
:ID:       468001dc-ec7e-454c-aef6-5559c240f146
:END:

#+begin_src elisp :tangle sm-exwm-core.el
;;;; Selection

;;;###autoload
(defun sm-exwm-core-visual-char ()
  "Start visual char selection."
  (interactive)
  (sm-exwm-xdotool-send-key "Shift" 'right))

;;;###autoload
(defun sm-exwm-core-visual-line ()
"Start visual line selection."
  (interactive)
  (exwm-input--fake-key 'home)
  (sm-exwm-xdotool-send-key "Shift+End")
  (evil-visual-state))

;;;###autoload
(defun sm-exwm-core-select-all ()
  "Select whole page."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl+a"))

#+end_src

** Find and search operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:22]
:ID:       daa8e452-7e02-4b2f-a081-45f97eeaeedf
:END:

#+begin_src elisp :tangle sm-exwm-core.el
;;; Find/Search

;;;###autoload
(defun sm-exwm-core-find ()
  "Find general."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'f))

;;;###autoload
(defun sm-exwm-core-search ()
  "Search for texts containing a given string."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'r))

;;;###autoload
(defun sm-exwm-core-find-elements ()
  "Find elements."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'f))

;;;###autoload
(defun sm-exwm-core-search-phrase ()
  "Search currently selected phrase."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'f3))

;;;###autoload
(defun sm-exwm-core-search-element-id ()
  "Goto element with a given element-id"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'g))

;;;###autoload
(defun sm-exwm-core-find-next ()
  "Find next."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'g))

;;;###autoload
(defun sm-exwm-core-find-previous ()
  "Find previous."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl Shift" 'g))

#+end_src

** Editing
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:25]
:ID:       1d576d49-e772-40ec-a57c-2160d44fd808
:END:

#+begin_src elisp :tangle sm-exwm-core.el
;;; Editing

;;;###autoload
(defun sm-exwm-core-escape ()
  (interactive)
  (exwm-input--fake-key 'escape))

;;;###autoload
(defun sm-exwm-core-paste ()
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'v))

(defun sm-exwm-core-paste-html ()
  "Paste html from clipboard."
   (interactive)
   (sm-exwm-xdotool-send-key "Shift" 'f10)
   (exwm-input--fake-key 'x)
   (exwm-input--fake-key 'p))

;;;###autoload
(defun sm-exwm-core-copy ()
  "Copy to clipboard."
   (interactive)
   (sm-exwm-xdotool-send-key "ctrl" 'c))

;;;###autoload
(defun sm-exwm-core-cut ()
  "Cut text."
   (interactive)
   (sm-exwm-xdotool-send-key "ctrl" 'x))

;;;###autoload
(defun sm-exwm-core-undo ()
  "Undo."
   (interactive)
   (sm-exwm-xdotool-send-key "ctrl" 'u))

;;;###autoload
(defun sm-exwm-core-redo ()
  "Redo."
   (interactive)
   (sm-exwm-xdotool-send-key "ctrl Shift" 'z))

;;;###autoload
(defun sm-exwm-core-bold ()
  "Embolden selected text"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'b))

;;;###autoload
(defun sm-exwm-core-italic ()
  "Italicise selected text."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'i))

;;;###autoload
(defun sm-exwm-decrease-font ()
  "Decrease selected font size"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" '\[))

;;;###autoload
(defun sm-exwm-increase-font ()
  "Increase selected font size"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" '\]))

;;;###autoload
(defun sm-exwm-core-edit-question ()
  "Edit the question component"
  (interactive)
  (exwm-input--fake-key 'escape)
  (exwm-input--fake-key 'q))

;;;###autoload
(defun sm-exwm-core-edit-answer ()
  "Edit the first answer"
  (interactive)
  (exwm-input--fake-key 'escape)
  (exwm-input--fake-key 'a))

;;;###autoload
(defun sm-exwm-core-edit-file ()
  "Edit .HTM file"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'f9))

;;;###autoload
(defun sm-exwm-core-edit-next-component ()
  "Edit the next component in element window"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 't))

;;;###autoload
(defun sm-exwm-core-edit-switch-mode ()
  "Cycle presentation -> editing -> dragging modes"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'e))

#+end_src

** Element functions
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:45]
:ID:       6f4b7ba2-8c14-4a7f-a03a-06dd3f193523
:END:

#+begin_src elisp :tangle sm-exwm-core.el
;;;###autoload
(defun sm-exwm-core-elements-dismiss-element ()
"Dismiss element while in element window"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'd))

;;;###autoload
(defun sm-exwm-core-element-params ()
  "Bring up apply template menu"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'p))

;;;###autoload
(defun sm-exwm-core-insert-image ()
  "Insert image into component."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'F8))

;;;###autoload
(defun sm-exwm-core-insert-splitline ()
  "Insert splitline in the component menu"
  (interactive)
  (sm-exwm-xdotool-send-key "Shift alt" 'h))

;;;###autoload
(defun sm-exwm-core-cycle-image-stretch ()
  "Cycle stretch of image component."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'q))

;;;###autoload
(defun sm-exwm-core-apply-template ()
  "Bring up apply template menu"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl Shift" 'm))

;;;###autoload
(defun sm-exwm-core-item-picture ()
  "Apply Item Picture template to element"
  (interactive)
  (sm-exwm-core-apply-template)
  (sm-exwm-xdotool-send-string "Item Article"))

;;;###autoload
(defun sm-exwm-core-item-picture ()
  "Apply Item Picture template to element"
  (interactive)
  (sm-exwm-core-apply-template)
  (sm-exwm-xdotool-send-string "Item Picture"))

;;;###autoload
(defun sm-exwm-core-import-component ()
  "Import component in element window"
  (interactive)
  ;; TODO direct this to the `sm-element-window'
  (sm-exwm-xdotool-send-key "ctrl" 'q))

;;;###autoload
(defun sm-exwm-core-reorder-components ()
  "Bring up reorder components menu"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'o))

;;;###autoload
(defun sm-exwm-core-reference-label ()
  "Bring up references menu"
  (interactive)
  (sm-exwm-xdotool-send-key "alt" 'q))

;;;###autoload
(defun sm-exwm-core-test-rep-cycle ()
  "Emulate learning mode to test element/components"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl alt" 'l))

;;;###autoload
(defun sm-exwm-core-tile-components ()
  "Go into tiling menu for component tiling"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl alt" 't))

(defun sm-exwm-core-ancestors ()
"Bring up element ancestors menu"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl Shift" 'x))

(defun sm-exwm-core-create-hyperlink ()
"Create hyperlink over selected text"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'k))

;; (defun sm-exwm-core-get-filepath ()
;; "Get the file path of the current element"
;;   (interactive)
;;   (sm-exwm-xdotool-send-key "~/.scripts/ahk/get-filepath.exe"))
#+end_src

translate winpath
#+begin_src elisp :tangle no
(let ((unix-path (replace-regexp-in-string "\n\\'" ""
                  (shell-command-to-string
                   (shell-quote-argument "winepath -u $(xclip -sel clip -o)"))))))
(shell-command "xclip -sel clip -o")

(subst-char-in-string ?\\ ?\ (gui--selection-value-internal 'CLIPBOARD))
#+end_src

** Learn operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:46]
:ID:       88b59ad6-d7ea-4e85-b828-c147fa4bb902
:END:

#+begin_src elisp :tangle sm-exwm-core.el
;;; Learn operations

;;;###autoload
(defun sm-exwm-core-learn ()
  "Start learning."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'l))

;;;###autoload
(defun sm-exwm-core-execute-rep ()
  "Execute repition."
  (interactive)
  (exwm-input--fake-key 'enter))

;;;###autoload
(defun sm-exwm-core-replay ()
  "Replay component."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'F10))

;;;###autoload
(defun sm-exwm-core-cloze ()
  "Extract selected text."
  (interactive)
  (sm-exwm-xdotool-send-key "alt" 'z))

;;;###autoload
(defun sm-exwm-core-extract ()
  "Extract selected text."
  (interactive)
  (sm-exwm-xdotool-send-key "alt" 'x))

;;;###autoload
(defun sm-exwm-core-schedule-extract ()
  "Extract and schedule for a later time."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl alt" 'x))

;;;###autoload
(defun sm-exwm-core-prioritize ()
  "Modify priority of current element."
  (interactive)
  ;;TODO perhaps enter char-mode or create hydra on window
  (sm-exwm-xdotool-send-key "alt" 'p))

;;;###autoload
(defun sm-exwm-core-reschedule ()
  "Learning: Reschedule to another day."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'j))

;;;###autoload
(defun sm-exwm-core-postpone ()
  "Schedule review later today."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl Shift" 'j))

;;;###autoload
(defun sm-exwm-core-remember ()
  "Introduce element into learning que."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'm))

;;;###autoload
(defun sm-exwm-core-execute-rep ()
  "Execute a mid-interval rep at later date."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl Shift" 'r))

;;;###autoload
(defun sm-exwm-core-cancel-grade ()
  "Undo grading on element."
  (interactive)
  (sm-exwm-xdotool-send-key "alt" 'g))

;;;###autoload
(defun sm-exwm-core-branch-learning ()
  "Subset review of a selection of a branch in contents."
  (interactive)
;;; TODO somekind of buffer check
  (sm-exwm-xdotool-send-key "ctrl" 'l))

;;;###autoload
(defun sm-exwm-core-random-learning ()
  "Random learning."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'f11))

;;;###autoload
(defun sm-exwm-core-random-test ()
  "Random test."
  (interactive)
  ;; TODO target browser window
  (sm-exwm-xdotool-send-key "ctrl" 'f11))

;;;###autoload
(defun sm-exwm-core-set-read-point ()
  "Set the read-point."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'f7))

;;;###autoload
(defun sm-exwm-core-mercy ()
  "Activate mercy."
  (interactive)
  (sm-exwm-xdotool-send-key "Shift alt" 'm))

;;;###autoload
(defun sm-exwm-core-neural ()
  "Go neural."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'F2))

;;;###autoload
(defun sm-exwm-core-sorting-criteria ()
  "Open sorting criteria window."
  (interactive)
  (sm-exwm-xdotool-send-key "alt" 'l)
  (exwm-input--fake-key 'o)
  (exwm-input--fake-key 'c))

;;;###autoload
(defun sm-exwm-core-subset-learning ()
  "Subset learning."
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'l))

#+end_src

** Knowledge tree operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 15:27]
:ID:       a34b8b01-dc40-4ee0-be9c-fdc44715ba48
:END:

#+begin_src elisp :tangle sm-exwm-core.el
;;;###autoload
(defun sm-exwm-convert-to-concept ()
  "Convert element to concept"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl+k"))

;;;###autoload
(defun sm-exwm-new-article ()
  "Create new article"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl+n"))

#+end_src

** Misc operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 13:48]
:ID:       795a6453-5dfc-42e4-b2cf-735fdd224d0c
:END:

#+begin_src elisp :tangle sm-exwm-core.el
;;; Misc

;;;###autoload
(defun sm-exwm-core-sm-commander ()
  "Summon the SuperMemo Commander"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'return))

;;;###autoload
(defun sm-exwm-core-repair-collection ()
  "Bring up the collection repair menu"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'f12))

;;;###autoload
(defun sm-exwm-core-restore-layout ()
  "Restore the default window layout"
  (interactive)
  (sm-exwm-xdotool-send-key "ctrl" 'f5))

;;;###autoload
(defun sm-exwm-core-statistics-analysis ()
  "Open stats window"
  (interactive)
  (sm-exwm-xdotool-send-key "Shift+alt+a"))

;;;###autoload
(defun sm-exwm-core-open-file ()
  "Open file."
  (interactive)
  (exwm-input--fake-key ?\C-o))

;;;###autoload
(defun sm-exwm-core-quit ()
  "Quit sm."
  (interactive)
  (exwm-input--fake-key ?\C-q))

(provide '+sm-exwm-core)
#+end_src

** TODO Try get ~input-fake-key~ working with Wine
:PROPERTIES:
:CREATED:  [2020-12-08 Tue 15:05]
:ID:       733fbf64-129d-4b63-8b92-8fcc569c5627
:END:

Testing some elisp functions to convert Windows paths from Wine to Linux
#+begin_src elisp :tangle no
(defun my-translate-winpath ()
  "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (shell-command-to-string (format "~/.scripts/winpath.sh %s" path))))

(defun my-translate-winpath ()
  "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (my-translate-path)))

(defun my-translate-winpath ()
  (interactive)
  (let* ((path (s-chop-prefix "z:" (current-kill 0 'do-not-move)))
         (nixpath (s-replace "\\" "/" path))
         (path1 (s-replace "documents" "Documents" nixpath)))
    (s-replace "sm" "SM" path1)))
#+end_src

Let's test this with Xdotool. It works, but isn't reliable.
#+begin_src elisp :tangle no
(defun sm-exwm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
(progn)
(my-translate-winpath)
;; (sit-for 3)
(message sm-path-nix))

(defun sm-exwm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))

(defun sm-exwm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
(progn
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
  (gui--selection-value-internal 'CLIPBOARD)))

(defun sm-exwm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
(lambda ()
)
  (setq sm-path (gui--selection-value-internal 'CLIPBOARD)))
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))
#+end_src

Testing with EXWM functionality (elisp only).
The big issue here is that control keys are not passed on to the Wine application. However, they are when using ~exwm-input-send-next-key~.
#+begin_src elisp :tangle no
(defun sm-exwm-core-test()
  "test"
  (interactive)
  ;; (exwm--log)
  ;; (let ((exwm-input-line-mode-passthrough t))
         ;; (key "?/C-v"))
         ;; (key (read-key "22")))
    (exwm-input--fake-key ("?/C-s-o")))

(exwm-input-set-key (kbd "<f9>") #'sm-exwm-core-test)


;;;###autoload
(defun sm-exwm-core-test ()
  "Move down."
  (interactive)
  (let ((exwm-input-line-mode-passthrough t))
    (exwm-input--fake-key 'left)))
#+end_src

#+RESULTS:

Try and get the right key code
#+begin_src elisp :tangle no
;; (read-key)
(vector "v")
#+end_src

#+RESULTS:
: ["? C-v"]

Trying the same but with a string.
#+begin_src elisp :tangle no
(defun my-exwm-send-string (string)
  "Send STRING to `exwm-mode' buffer or just insert it."
  (if (eq major-mode 'exwm-mode)
      (mapc #'exwm-input--fake-key (string-to-list string))
    (insert string)))

(defun sm-exwm-core-string-test ()
  (interactive)
  ;; (let ((exwm-input-line-mode-passthrough t))
    ;; (my-exwm-send-string [#o26])))
  (my-exwm-send-string [94 3]))

;; (term-send-raw-string "l")

;; (read-key-sequence-vector)

(exwm-input-set-key (kbd "<f9>") #'sm-exwm-core-string-test)
;; ###autoload
;; (defun sm-exwm-core-test ()
;;   "Send string to a given exwm buffer"
;;   (interactive)
;;   (my-exwm-send-string "sm-get-path ")
;;   (find-file (my-translate-winpath)))
#+end_src

Try with this
#+begin_src elisp :tangle no
(cl-defun exwm-input-send-sim-key (key)
  "Fake a key event according to the last input key sequence."
  (interactive)
  (exwm--log)
  (unless (derived-mode-p 'exwm-mode)
    (cl-return-from exwm-input-send-simulation-key))
  (let ((keys (gethash (this-single-command-keys)
                       exwm-input--simulation-keys)))
    (dolist (key keys)
      (exwm-input--fake-key key))))
#+end_src

#+begin_src elisp :tangle no
(cl-defun my-exwm-input-send-next-key (keys)
  "Send next key to client window.

EXWM will prompt for the key to send.  This command can be prefixed to send
multiple keys.  If END-KEY is non-nil, stop sending keys if it's pressed."
  (interactive "p")
  (exwm--log)
  (unless (derived-mode-p 'exwm-mode)
    (cl-return-from my-exwm-input-send-next-key))
  (let (key keys)
      ;; Skip events not from keyboard
      (let ((exwm-input-line-mode-passthrough t))
            ;; (setq key (read-key (format (key-description keys))
        (setq key (key-description "?\C-v")))
      (setq keys (vconcat keys (vector key)))
      (exwm-input--fake-key key)))
#+end_src

#+begin_src elisp :tangle no
(defun sm-exwm-core-test()
  "test"
  (interactive)
  (exwm/enter-char-mode)
  (exwm-input--fake-key ?\C-v))

  ;; (exwm-input-release-keyboard)
(defun sm-exwm-core-test ()
  "Copy text."
  (interactive)
  (exwm-input--invoke--m))
(exwm-input-invoke-factory "m")

;;;###autoload
(defun sm-exwm-core-copy ()
  "Copy text."
  (interactive)
  (exwm-input--fake-key ?\C-c))

#+end_src

* sm-evil
:PROPERTIES:
:CREATED:  [2020-11-21 Sat 10:31]
:ID:       c792bb4f-4d32-4eaf-a7b4-aa521e5dfcde
:END:

#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;;; desktop/exwm/+sm-exwm-evil.el -*- lexical-binding: t; -*-

(require 'evil)
(require 'evil-core)
(require '+sm-exwm-core)

(defvar sm-exwm-evil-sm-class-name '("sm18.exe")
  "The class name use for detecting if a SM buffer is selected.")

;; (defvar sm-exwm-evil-sm-buffer-name '(sm-element-window)
;;   "The buffer name used for detecting if a SM buffer is selected.")

;;; State transitions
(defun sm-exwm-evil-normal ()
  "Pass every key directly to Emacs."
  (interactive)
  (setq-local exwm-input-line-mode-passthrough t)
  (evil-normal-state))

(defun sm-exwm-evil-insert ()
  "Pass every key to SM."
  (interactive)
  (setq-local exwm-input-line-mode-passthrough nil)
  (evil-insert-state))

(defun sm-exwm-evil-visual ()
  "Visual mode!"
  (interactive)
  (setq-local exwm-input-line-mode-passthrough t)
  (shell-command
   (format "xdotool keydown Shift sleep 0.1"))
  (evil-visual-state))

(defun sm-exwm-evil-exit-visual ()
  "Exit visual state properly."
  (interactive)
  ;; Unmark any selection
  (shell-command
   (format "xdotool keyup Shift"))
  (sm-exwm-core-left)
  (sm-exwm-core-right)
  (sm-exwm-evil-normal))

(defun sm-exwm-evil-visual-change ()
  "Change text in visual mode."
  (interactive)
  (sm-exwm-core-cut)
  (sm-exwm-evil-insert))

;;; Keys
(defvar sm-exwm-evil-mode-map (make-sparse-keymap))

    ;;;; Transitions
;; Bind normal
(define-key sm-exwm-evil-mode-map [remap evil-exit-visual-state] 'sm-exwm-evil-exit-visual)
(define-key sm-exwm-evil-mode-map [remap evil-normal-state] 'sm-exwm-evil-normal)
(define-key sm-exwm-evil-mode-map [remap evil-force-normal-state] 'sm-exwm-evil-normal)
(define-key sm-exwm-evil-mode-map [remap evil-visual-state] 'sm-exwm-evil-visual)
;; Bind insert
(define-key sm-exwm-evil-mode-map [remap evil-insert-state] 'sm-exwm-evil-insert)
(define-key sm-exwm-evil-mode-map [remap evil-insert] 'sm-exwm-evil-insert)
(define-key sm-exwm-evil-mode-map [remap evil-substitute] 'sm-exwm-evil-insert)
(define-key sm-exwm-evil-mode-map [remap evil-append] 'sm-exwm-evil-insert)

#+end_src

** Normal mode maps
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       fdf9c4a5-abeb-424c-97f5-8eddf3ccf5bc
:END:

#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;;;; Normal
;; Basic movements

(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "w") 'sm-exwm-core-forward-word-test)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "k") 'sm-exwm-core-up)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "j") 'sm-exwm-core-down)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "h") 'sm-exwm-core-left)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "l") 'sm-exwm-core-right)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "K") 'sm-exwm-core-goto-parent)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "J") 'sm-exwm-core-goto-child)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "H") 'sm-exwm-core-back)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "L") 'sm-exwm-core-forward)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "w") 'sm-exwm-core-word)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "b") 'sm-exwm-core-word-back)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "0") 'sm-exwm-core-beginning-of-line)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "$") 'sm-exwm-core-end-of-line)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "/") 'sm-exwm-core-find)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "t") 'sm-exwm-core-test)
;; (evil-define-key 'normal sm-exwm-evil-mode-map (kbd "<escape>") 'sm-exwm-core-escape)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "<return>") '(lambda () (interactive) (exwm-input--fake-key 'return)))
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "RET") '(lambda () (interactive) (exwm-input--fake-key 'return)))

;;; Motion State
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "gg") 'sm-exwm-core-goto-first-line)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "G") 'sm-exwm-core-goto-last-line)

(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "gq") 'sm-exwm-core-edit-question)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "ga") 'sm-exwm-core-edit-answer)

(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "C-u") 'sm-exwm-core-scroll-up)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "C-d") 'sm-exwm-core-scroll-up)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "C-b") 'sm-exwm-core-scroll-page-up)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "C-e") 'sm-exwm-core-scroll-line-down)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "C-f") 'sm-exwm-core-scroll-page-down)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "C-y") 'sm-exwm-core-scroll-line-up)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "RET") 'sm-exwm-core-execute-rep)
#+end_src

#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;;; Editing text
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "y") 'sm-exwm-core-copy)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "d") 'sm-exwm-core-cut)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "p") 'sm-exwm-core-paste)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "u") 'sm-exwm-core-undo)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "C-r") 'sm-exwm-core-redo)

#+end_src

#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;;; Learn operations
;; (evil-define-key 'normal sm-exwm-evil-mode-map (kbd "d") 'sm-exwm-core-contents-dismiss-element)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "x") 'sm-exwm-core-extract)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "X") 'sm-exwm-core-schedule-extract)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "SPC") 'sm-exwm-core-learn)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd ",") 'nanjigen/sm-hydra/body)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "P") 'sm-exwm-core-prioritize)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "s") 'sm-exwm-core-reschedule)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "o") 'sm-exwm-core-get-filepath)
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "r") 'sm-exwm-core-replay)

(map! :map sm-exwm-evil-mode-map
      :n "SPC" #'sm-exwm-core-learn)

#+end_src

** Visual maps
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       f291281f-7415-4251-9ee2-263263661236
:END:

#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;; Selection
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "V") '(lambda
                                                             ()
                                                             (interactive)
                                                             (exwm-input--fake-key 'end)
                                                             (sm-exwm-evil-visual)
                                                             (exwm-input--fake-key 'up)))
(evil-define-key 'normal sm-exwm-evil-mode-map (kbd "v") '(lambda
                                                             ()
                                                             (interactive)
                                                             (sm-exwm-evil-visual)
                                                             (exwm-input--fake-key 'right)))

#+end_src


#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;;;; Visual
;; Basic movements
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "k") 'sm-exwm-core-up)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "j") 'sm-exwm-core-down)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "h") 'sm-exwm-core-left)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "l") 'sm-exwm-core-right)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "K") 'sm-exwm-core-goto-parent)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "J") 'sm-exwm-core-goto-child)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "H") 'sm-exwm-core-back)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "L") 'sm-exwm-core-forward)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "w") 'sm-exwm-core-word)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "b") 'sm-exwm-core-word-back)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "{") 'sm-exwm-core-visual-backward-paragraph)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "}") 'sm-exwm-core-visual-forward-paragraph)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "b") 'sm-exwm-core-word-back)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "/") 'sm-exwm-core-find)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "t") 'sm-exwm-core-test)
;; (evil-define-key 'normal sm-exwm-evil-mode-map (kbd "<escape>") 'sm-exwm-core-escape)
(evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "<return>") '(lambda () (interactive) (exwm-input--fake-key 'return)))
(evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "RET") '(lambda () (interactive) (exwm-input--fake-key 'return)))

;;; Motion State
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "gg") 'sm-exwm-core-goto-first-line)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "G") 'sm-exwm-core-goto-last-line)

(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "gq") 'sm-exwm-core-edit-question)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "ga") 'sm-exwm-core-edit-answer)

(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "C-u") 'sm-exwm-core-scroll-up)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "C-d") 'sm-exwm-core-scroll-up)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "C-b") 'sm-exwm-core-scroll-page-up)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "C-e") 'sm-exwm-core-scroll-line-down)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "C-f") 'sm-exwm-core-scroll-page-down)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "C-y") 'sm-exwm-core-scroll-line-up)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "RET") 'sm-exwm-core-execute-rep)
#+end_src

#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;; Selection
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "y") 'sm-exwm-core-copy)
#+end_src

#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;;; Editing text
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "y") 'sm-exwm-core-copy)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "d") 'sm-exwm-core-cut)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "p") 'sm-exwm-core-paste)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "u") 'sm-exwm-core-undo)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "C-r") 'sm-exwm-core-redo)

#+end_src

#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;;; Learn operations
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "x") 'sm-exwm-core-extract)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "X") 'sm-exwm-core-schedule-extract)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "SPC") 'sm-exwm-core-learn)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd ",") 'nanjigen/sm-hydra/body)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "P") 'sm-exwm-core-prioritize)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "s") 'sm-exwm-core-reschedule)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "o") 'sm-exwm-core-get-filepath)
(evil-define-key 'visual sm-exwm-evil-mode-map (kbd "r") 'sm-exwm-core-replay)

(map! :map sm-exwm-evil-mode-map
      :n "SPC" #'sm-exwm-core-learn)

#+end_src

** End
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       ca5c53de-2eb7-4445-9b25-6641ac7f6733
:END:

#+begin_src elisp :noweb yes :tangle sm-exwm-evil.el
;;; Mode
;;;###autoload
(define-minor-mode sm-exwm-evil-mode nil nil nil sm-exwm-evil-mode-map
  (if sm-exwm-evil-mode
      (progn
        (sm-exwm-evil-normal))))

;;;###autoload
(defun sm-exwm-evil-activate-if-sm ()
  "Activates sm-exwm mode when buffer is SM.
SM variant can be assigned in 'sm-exwm-evil-sm-name`"
  (interactive)
  (if (member exwm-class-name sm-exwm-evil-sm-class-name)
      (sm-exwm-evil-mode 1)))

(provide '+sm-exwm-evil)

;;; +sm-exwm-evil.el ends here
#+end_src

#+RESULTS:
: +sm-exwm-evil

* sm-hydra
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:49]
:ID:       70ea4d74-e725-4448-b1fe-10c10eaa5a9a
:END:

By using a =hydra-title= like [[file:~/.emacs.d/.local/straight/repos/org-media-note/org-media-note.el::defun org-media-note--hydra-title (][here]], I can have commands run in the background to influence the names of hydra commands.
#+begin_src elisp :tangle sm-hydra.el
;;; desktop/exwm/+sm-hydra.el -*- lexical-binding: t; -*-
(pretty-hydra-define nanjigen/sm-hydra
  (:color red
   ;; :title (--hydra-title)
   :hint nil)
  ("Learn"
   (("rr" (sm-exwm-core-remember) "Remember")
    ("c" (sm-exwm-core-cancel-grade) "Undo grading")
    ("s" (nanjigen/sm-subset-hydra/body) "Subset operations")
    ("rs" (sm-exwm-core-set-read-point) "Set read point")
    ("m" (sm-exwm-core-mercy) "Mercy")
    ("S" (sm-exwm-core-sorting-criteria) "Sorting Criteria"))
  "Editing"
   (("i" (sm-exwm-core-italic) "italics")
    ("b" (sm-exwm-core-bold) "bold")
    ("q" (sm-exwm-core-edit-question) "Edit Question")
    ("a" (sm-exwm-core-edit-answer) "Edit Answer")
    ("n" (sm-exwm-core-edit-answer) "Edit Next Component")
    ("f" (sm-exwm-core-edit-file) "Edit File"))
  "Misc"
   (("SPC" (sm-exwm-core-sm-commander) "SuperMemo Commander")
    ("rc" (sm-exwm-core-repair-collection) "Repair Collection")
    ("rl" (sm-exwm-core-restore-layout) "Restore layout")
    ("A" (sm-exwm-core-statistics-analysis) "Stats window"))))

#+end_src

#+begin_src elisp :tangle sm-hydra.el
;;; desktop/exwm/+sm-hydra.el -*- lexical-binding: t; -*-
(pretty-hydra-define nanjigen/sm-subset-hydra
  (:color red
   ;; :title (--hydra-title)
   :hint nil)
  ("Learn"
   (("b" (sm-exwm-core-branch-learning) "Branch learning")
    ("r" (sm-exwm-core-random-learning) "Random learning")
    ("t" (sm-exwm-core-random-test) "Random test")
    ("n" (sm-exwm-core-neural) "Go neural")
    ("s" (sm-exwm-core-subset-learning) "Subset learning"))))

#+end_src

* sm desktop
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       c5515f7e-a0c6-40d8-8b60-36b4334874ad
:END:

.desktop file:
#+begin_src conf
[Desktop Entry]
Name=SuperMemo 18 (ms-office)
Exec=env WINEPREFIX="/home/nanjigen/.local/share/wineprefixes/ms-office" wine "/home/nanjigen/.local/share/wineprefixes/ms-office/drive_c/SuperMemo/sm18.exe"
Type=Application
Categories=Education;
StartupNotify=true
Comment=Organize your knowledge and learn at the maximum possible speed
Path=/home/nanjigen/.local/share/wineprefixes/ms-office/drive_c/SuperMemo
Icon=/home/nanjigen/.local/share/wineprefixes/ms-office/drive_c/SuperMemo/smicon.png
StartupWMClass=sm18.exe
#+end_src

* org-protocol
:PROPERTIES:
:CREATED:  [2021-02-19 Fri 13:42]
:ID:       4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b
:END:

By using ~org-protocol~, we can call =emacsclient= from other applications by specifying a link recognised by the OS (whether is be Linux or Windows).

First we declare a regedit for WINE, in which we allow Windows to recognise the ~org-protocol:~ scheme handler:
https://github.com/nobiot/Zero-to-Emacs-and-Org-roam/blob/main/90.org-protocol.md

#+title: org-protocol wine
#+begin_src conf :tangle org-protocol.reg
Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\org-protocol]
@="URL:Org Protocol"
"URL Protocol"=""
[HKEY_CLASSES_ROOT\org-protocol\shell]
[HKEY_CLASSES_ROOT\org-protocol\shell\open]
[HKEY_CLASSES_ROOT\org-protocol\shell\open\command]
@="C:\\windows\\system32\\winebrowser.exe -nohome \"%1\""
#+end_src

#+title: native browser wine
#+begin_src conf :tangle nativebrowser.reg
Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\htmlfile\shell\open\command]
@="C:\\windows\\system32\\winebrowser.exe -nohome \"%1\""
[-HKEY_CLASSES_ROOT\htmlfile\shell\open\ddeexec]
[HKEY_CLASSES_ROOT\htmlfile\shell\opennew\command]
@="C:\\windows\\system32\\winebrowser.exe -nohome \"%1\""
[-HKEY_CLASSES_ROOT\htmlfile\shell\opennew\ddeexec]


[HKEY_CLASSES_ROOT\http\shell\open\command]
@="C:\\windows\\system32\\winebrowser.exe -nohome \"%1\""
[-HKEY_CLASSES_ROOT\http\shell\open\ddeexec]

[HKEY_CLASSES_ROOT\https\shell\open\command]
@="C:\\windows\\system32\\winebrowser.exe -nohome \"%1\""
[-HKEY_CLASSES_ROOT\https\shell\open\ddeexec]

[HKEY_CURRENT_USER\Software\Wine\WineBrowser]
"Browsers"="xdg-open,firefox,konqueror,mozilla,netscape,galeon,opera,dillo"
#+end_src

#+begin_src sh
env WINEPREFIX="/home/nanjigen/.local/share/wineprefixes/supermemo18" wine regedit org-protocol.reg nativebrowser.reg
#+end_src

#+begin_src conf :tangle ~/.local/share/applications/org-protocol.desktop
[Desktop Entry]
Name=org-protocol
Exec=emacsclient -n %u
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+end_src

The mime types can be queried and configured with the ~xdg-mime~ command:
#+begin_src sh

#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/lang/org-private/+org-protocol.el
;;; lang/org-private/+org-protocol.el -*- lexical-binding: t; -*-

(use-package! org-protocol
  :after org
  :config
  <<org-protocol handlers>>
  )

<<org-export backend>>

#+end_src

The whole protocol system can be fairly complex in terms of flow. Let's draw a diagram to better explain our intention:

** Custom org-protocol handlers
:PROPERTIES:
:CREATED:  [2021-03-01 Mon 15:07]
:ID:       c342cd1d-25eb-499f-9bf5-d1b4dbf1e470
:header-args: :noweb-ref org-protocol handlers
:END:

Then we can write a custom org-id [[https://emacs.stackexchange.com/questions/47986/jump-to-org-mode-heading-from-external-application][protocol handler]]:
#+begin_src elisp

(add-to-list 'org-protocol-protocol-alist
             '("org-id" :protocol "org-id"
               :function org-id-protocol-goto-org-id))

(defun org-id-protocol-goto-org-id (info)
  "This handler simply goes to the org heading with given id using emacsclient.

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the id key, pointing to the path of the org id.

      Example protocol string:
      org-protocol://org-id?id=309A0509-81BE-4D51-87F4-D3F61B79EBA4"
  (when-let ((id (plist-get info :id)))
    (org-id-goto id))
  nil)

(defun org-id-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://org-id?id="
                        (org-id-copy))))

#+end_src

#+begin_src elisp
(add-to-list 'org-protocol-protocol-alist
             '("brain-id" :protocol "brain-id"
               :function brain-id-protocol-visualize-brain-id))

(defun brain-id-protocol-visualize-brain-id (info)
  "This handler visualizes the org heading with given id using emacsclient.

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the id key, pointing to the path of the org id.

      Example protocol string:
      org-protocol://brain-id?id=309A0509-81BE-4D51-87F4-D3F61B79EBA4"
  (when-let ((id (plist-get info :id)))
    (org-brain-visualize (or (org-brain-entry-from-id id))))
  nil)

(defun brain-id-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://brain-id?id="
                        (org-id-copy))))

#+end_src

#+begin_src elisp
(add-to-list 'org-protocol-protocol-alist
             '("pdf-tools" :protocol "pdf-tools"
               :function pdftools-protocol-pop-pdf))

(defun pdftools-protocol-pop-pdf (info)
  "This opens the highlight location of the given extract

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the org-pdf-tools link, pointing to the path of the org id.

      Example protocol string:
      org-protocol://brain-id?id=309A0509-81BE-4D51-87F4-D3F61B79EBA4"
  (when-let ((link (plist-get info :pdf)))
    (org-link-open-from-string (format "[[pdf:%s]]" link)))
  nil)

(defun pdf-tools-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://pdf-tools?pdf="
                        (org-entry-get nil "NOTER_PAGE"))))

(defun pdft-tools-protocol-htmlfier ()
  (interactive)
  (let ((pdf-link (org-entry-get nil "ID")))
    (format "<a href=\"org-protocol://pdf-tools?pdf=%s\"></a>" pdf-link)))

(defun pdf-tools-protocol-html-link-copy ()
  (interactive)
  (org-kill-new (concat "<a href=\"org-protocol://pdf-tools?pdf="
                        (org-entry-get nil "NOTER_PAGE") "</a>")))

#+end_src
"<a href=\"org-protocol://brain-id?id=%s\">%s</a>"

We also want the ability to store an ~org-id~ UUID translated /back/ from the =attach-dir=. This will allow us to act upon the source file if we choose to take notes on the video file.

#+begin_src elisp
(defun org-attach-id-from-dir (id)
  "Translate a org-attach dir folder-path back into an UUID ID"
  (format "%s%s"
  (substring id 0 2)
  (substring id 3)))

#+end_src

Do some simple string splitting. This hopefully conforms to the way this kind of information is normally handled in =org-mode/org-media-note=.
#+begin_src elisp
(add-to-list 'org-protocol-protocol-alist
             '("media-link" :protocol "media-link"
               :function media-link-protocol-play-mpv-video))

(defun media-link-protocol-play-mpv-video (info)
  "This handler visualizes the org heading with given id using emacsclient.

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the id key, pointing to the path of the org id.

      Example protocol string:
      org-protocol://media-link?video=~/org/.attach/27/e2318b-7353-4004-943a-2f1d69b32209/doge_vid420.mpg#0:00:13"
  (when-let ((link (plist-get info :video)))
    (let* ((org-style-link (format "[[video:%s]]" link))
           (splitted (split-string org-style-link "/"))
           (id (format "%s%s"
                       (nth 3 splitted)
                       (nth 4 splitted))))
        ;; (org-link-open-from-string (format "[[video:%s]]" link))
        (setq org-protocol-uuid-from-media-link id)
        (setq org-protocol-last-visited-link org-style-link)
        (org-link-open-from-string org-style-link))
        nil))

  (defun nanjigen/org-media-note-jump-to-note ()
    (interactive)
    (let* ((buffer (org-id-find org-protocol-uuid-from-media-link))
          (link-text (nth 5
                          (split-string org-protocol-last-visited-link "/")))
          (link-text-clean (substring link-text 0 -2)))
      (progn
        (org-id-open org-protocol-uuid-from-media-link t)
        (org-narrow-to-subtree)
        (search-forward link-text-clean)
        (recenter nil))))

(defun media-link-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://media-link?video="
                        (org-id-copy))))

#+end_src

Now we can use the stored variables and on request open the location of the link in a buffer for note-taking.

See =org-noter--create-session= for inspiration
#+begin_src elisp
(defun nanjigen/org-media-note--create-session ()
  (let* ((notes-buffer
          (make-indirect-buffer)))))
#+end_src

#+begin_src elisp
(defun media-link-protocol-play-cite-video (info)
"This handler visualizes the org heading with given id using emacsclient.

  INFO is an alist containing additional information passed by the protocol URL.
  It should contain the id key, pointing to the path of the org id.

    Example protocol string:
    org-protocol://media-link?videocite=~/org/.attach/27/e2318b-7353-4004-943a-2f1d69b32209/doge_vid420.mpg#0:00:13"
(when-let ((link (plist-get info :videocite)))
  (org-link-open-from-string (format "[[videocite:%s]]" link)))
nil)

(defun media-link-protocol-cite-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://media-link?videocite="
                        (org-media-note--current-org-ref-key))))
#+end_src
org-protocol://media-link?video=https://www.youtube.com/watch?v=lW3eWIj3Q04#0:03:28-0:03:39
org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b
[[org-protocol://org-id/?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b]]
[[org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b]] ;; doesn't work

Because we have defined a regedit, with the right formatting, html links will redirect to the org-protocol handler as well:
#+begin_example html :tangle no
<A href="org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b">Link text here</A>
<A href="org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b">** org-protocol</A>
#+end_example

This can be directly pasted into an element with either =e= (for Questions) or =a= (for Answers) and then =M-<F10>-x-p= (Element pane -> Text -> Paste Html)

Now we can write a key script to automate this process, and bind it to a contextual hydra:

** org-export backend
:PROPERTIES:
:CREATED:  [2021-03-01 Mon 15:07]
:ID:       d2942d96-207d-4061-bcea-116f8a437b8d
:header-args: :noweb-ref org-export backend
:END:

To automate the process, we can write extend the =org-export= backend with [[https://kitchingroup.cheme.cmu.edu/blog/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions/][org-link-set-parameters]] to introduce the above protocol link into header text automatically
#+begin_src elisp
(cl-defgeneric brain-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod brain-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://brain-id?id=%s\">%s</a>" path desc))

(org-link-set-parameters "brain" :export 'brain-link-export)
#+end_src

=video:= link exporter
#+begin_src elisp
(cl-defgeneric media-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod media-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://media-link?video=%s\">%s</a>" path desc))

(org-link-set-parameters "video" :export 'media-link-export)
#+end_src

=videocite:= link exporter
#+begin_src elisp

;; this one runs when the backend is equal to html
(cl-defmethod media-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://media-link?video=%s\">%s</a>" path desc))

(org-link-set-parameters "video" :export 'media-link-export)

;; for videocite links
(cl-defgeneric videocite-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod videocite-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://media-link?videocite=%s\">%s</a>" path desc))

(org-link-set-parameters "videocite" :export 'videocite-link-export)
#+end_src

cite:key reference exporter
#+begin_src elisp
(cl-defgeneric cite-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod cite-link-export ((path t) (desc t) (backend (eql html)))
  (format "<a href=\"%s\">%s:%s</a>" path path desc))

(org-link-set-parameters "cite" :export 'cite-link-export)
#+end_src

Ideally targeting the ~:ID:~ property, extracting the =org-id= and generating the org-protocol link:
https://emacs.stackexchange.com/questions/156/emacs-function-to-convert-an-arbitrary-org-property-into-an-arbitrary-string-na

Modified =org-html-headline= from [[file:~/.emacs.d/.local/straight/repos/org-mode/lisp/ox-html.el::defun org-html-headline (headline contents info][ox-html.el]] :
#+begin_src elisp
(after! org
  (setq org-html-self-link-headlines t)

  (defun org-html-headline (headline contents info)
    "Transcode a HEADLINE element from Org to HTML.
    CONTENTS holds the contents of the headline.  INFO is a plist
    holding contextual information."
    (unless (org-element-property :footnote-section-p headline)
      (let* ((numberedp (org-export-numbered-headline-p headline info))
             (numbers (org-export-get-headline-number headline info))
             (level (+ (org-export-get-relative-level headline info)
                       (1- (plist-get info :html-toplevel-hlevel))))
             (todo (and (plist-get info :with-todo-keywords)
                        (let ((todo (org-element-property :todo-keyword headline)))
                          (and todo (org-export-data todo info)))))
             (todo-type (and todo (org-element-property :todo-type headline)))
             (priority (and (plist-get info :with-priority)
                            (org-element-property :priority headline)))
             (text (org-export-data (org-element-property :title headline) info))
             (tags (and (plist-get info :with-tags)
                        (org-export-get-tags headline info)))
             (full-text (funcall (plist-get info :html-format-headline-function)
                                 todo todo-type priority text tags info))
             (contents (or contents ""))
             (id (org-html--reference headline info))
             (brain-id (org-element-property :ID headline))
             (formatted-text
              ;; (if (plist-get info :html-self-link-headlines)
              ;;     (format "<a href=\"#%s\">%s</a>" id full-text)
              ;;   full-text)))
              (if (plist-get info :html-self-link-headlines)
                  (format "<a href=\"org-protocol://brain-id?id=%s\">%s</a>" brain-id full-text)
                full-text)))
        (if (org-export-low-level-p headline info)
            ;; This is a deep sub-tree: export it as a list item.
            (let* ((html-type (if numberedp "ol" "ul")))
              (concat
               (and (org-export-first-sibling-p headline info)
                    (apply #'format "<%s class=\"org-%s\">\n"
                           (make-list 2 html-type)))
               (org-html-format-list-item
                contents (if numberedp 'ordered 'unordered)
                nil info nil
                (concat (org-html--anchor id nil nil info) formatted-text)) "\n"
               (and (org-export-last-sibling-p headline info)
                    (format "</%s>\n" html-type))))
          ;; Standard headline.  Export it as a section.
          (let ((extra-class
                 (org-element-property :HTML_CONTAINER_CLASS headline))
                (headline-class
                 (org-element-property :HTML_HEADLINE_CLASS headline))
                (first-content (car (org-element-contents headline))))
            (format "<%s id=\"%s\" class=\"%s\">%s%s</%s>\n"
                    (org-html--container headline info)
                    (format "outline-container-%s" id)
                    (concat (format "outline-%d" level)
                            (and extra-class " ")
                            extra-class)
                    (format "\n<h%d id=\"%s\"%s>%s</h%d>\n"
                            level
                            id
                            (if (not headline-class) ""
                              (format " class=\"%s\"" headline-class))
                            (concat
                             (and numberedp
                                  (format
                                   "<span class=\"section-number-%d\">%s</span> "
                                   level
                                   (mapconcat #'number-to-string numbers ".")))
                             formatted-text)
                            level)
                    ;; When there is no section, pretend there is an
                    ;; empty one to get the correct <div
                    ;; class="outline-...> which is needed by
                    ;; `org-info.js'.
                    (if (eq (org-element-type first-content) 'section) contents
                      (concat (org-html-section first-content "" info) contents))
                    (org-html--container headline info)))))))
  )

#+end_src

** TODO add default browser defcustom to sm config

#+begin_src elisp
(defcustom 'sm-emacs-org-protocol-default-browser 'eww
  "default browser for opening `org-protocol' links from SM"
  :group sm-emacs
  :value ' )
#+end_src

* SM with Emacs
:PROPERTIES:
:CREATED:  [2021-01-04 Mon 15:52]
:ID:       a04ab1f5-a77b-4dec-8c59-3276246dfb88
:END:

** TODO Emacs UI for sm?
:PROPERTIES:
:CREATED:  [2022-07-07 Thu 08:54]
:ID:       cca714d5-2e65-4192-8117-041d29317eb4
:END:
https://lifeofpenguin.blogspot.com/2022/04/multi-select-tree-widget.html?m=1

** fs monitoring
:PROPERTIES:
:CREATED:  [2021-09-19 Sun 17:46]
:ID:       503009e6-6543-471d-b7a7-0bcfdf90aa94
:END:

Using =inotifywait= from the ~inotif-tools~ program we can watch the =$SM-COLLECTION/elements= folder recursively for file open events made by SuperMemo:
#+begin_src elisp :tangle sm-sentinel.el
;;; desktop/exwm/+sm-sentinel.el -*- lexical-binding: t; -*-

(defun sm-element-inotify-process ()
  "Watch for reads of element files in the collection dir"
  (interactive)
  (start-process
   "inotifywait"
   "*inotifywait*"
   "inotifywait" "-mrq" "-e" "open" "/home/nanjigen/Documents/SM/neuron/elements" "--include" ".HTM"))

#+end_src

And to watch image access:
#+begin_src elisp :tangle sm-sentinel.el
(defun sm-image-inotify-process ()
  "Watch for reads of image files in the collection dir"
  (interactive)
  (start-process
   "inotifywait-image"
   "*inotifywait-image*"
   "inotifywait" "-mrq" "-e" "open" "/home/nanjigen/Documents/SM/neuron/elements" "--include" "\.(jpg|gif|png|svg)"))
#+end_src

#+RESULTS:
: #<process inotifywait>

Setup a sentinel to watch for changes to the process buffer =*inotifywait*=
This is mostly for testing purposes
#+begin_src elisp :tangle sm-sentinel.el
(defun msg-me (process event)
  (princ
   (format "Process: %s had the event '%s'" process event)))
(set-process-sentinel (get-process "inotifywait") 'msg-me)

#+end_src

The function below captures all the paths outputted from the ~inotifywait~ process as seperate symbols in a single list. This is then transferred to a holding variable of the same make-up, and the original list is emptied. This way, on every file read when an element is accessed by SuperMemo, only those file paths are kept in the variable, instead of appending each new file found to the list.
#+begin_src elisp :tangle sm-sentinel.el
(defun keep-output (process output)
  "Store the paths of elements caught by inotify"
  (progn
    (setq captured-path (cons output captured-path))
    (sleep-for 0.1)
    (list-sm-element-paths)
    (setq captured-path nil)))

(defun keep-image-path (process output)
  "Store the paths of elements caught by inotify"
  (progn
    (setq captured-image-path (cons output captured-image-path))
    (sleep-for 0.1)
    (setq image-file-list (s-lines (s-replace " OPEN " "" (car captured-image-path))))
    (setq captured-image-path nil)))

#+end_src

#+begin_src elisp :tangle sm-sentinel.el
(defvar captured-image-path nil
  "The path captured by the inotify sentinel")

(defvar captured-path nil
  "The path captured by the inotify sentinel")

#+end_src

The below is some logic for determining if what was captured is a Topic or an element pair such as Q/A or a cloze. It then stores the path values as such.

#+begin_src elisp :tangle sm-sentinel.el
(defun list-sm-element-paths ()
  "Text munge captured paths"
  (setq sm-file-list (s-lines (s-replace " OPEN " "" (car captured-path))))
  (interactive)
  (if (> (length sm-file-list) 1)
      (progn
        (setq sm-element-item-p t)
        (setq sm-element-article-p nil))
    (progn
      (setq sm-element-item-p nil)
      (setq sm-element-article-p t))))

#+end_src

#+begin_src elisp :tangle sm-sentinel.el
(defvar sm-element-item-p nil
  "Whether currently viewed element is an item.")

(defvar sm-element-article-p nil
  "Whether currently viewed element is an article")

#+end_src

Get process and set sentinels:
#+begin_src elisp

(set-process-filter (get-process "inotifywait") 'keep-output)
(set-process-filter (get-process "inotifywait-image") 'keep-image-path)

#+end_src

#+begin_src elisp
(process-sentinel (get-process "inotifywait"))
#+end_src

Edit files:
#+begin_src elisp
(defun edit-component-as-org ()
  (interactive)
  (if sm-element-item-p t
    (let ((question (nth 0 file-list))
          (answer (nth 1 file-list)))
      (find-file question))))

#+end_src

Then we can parse these file read through to various =setq's= to be read in the background.

** sm launcher
:PROPERTIES:
:CREATED:  [2021-09-20 Mon 07:42]
:ID:       eec68fe9-9dc3-4591-9047-af0e4ea196b4
:END:

The wineprefix and drive_c should be named ~$PATHS~
#+begin_src elisp :tangle sm-emacs-protocol.el
(defun nanjigen/launch-sm-process ()
  "Launch SM as a process with 'start-process-shell-command'"
  (interactive)
  (start-process
   "SuperMemo18"
   "*Supermemo18*"
   (combine-and-quote-strings '("env WINEPREFIX="
                                "/home/nanjigen/.local/share/wineprefixes/supermemo18"
                                " LANG="
                                "ja_JP.utf8" ;; this is required to pass links containing CJK characters to org-protocol - TODO need a work around
                                " wine "
                                "/home/nanjigen/.local/share/wineprefixes/supermemo18/drive_c/SuperMemo/sm18.exe"
                                "") "\"")))

#+end_src

We have another ~wine~ process run this way for testing purposes:
#+begin_src elisp :tangle sm-emacs-protocol.el
(defun nanjigen/launch-notepad-process ()
  "Launch notepad as a process with 'start-process-shell-command'
this is used for testing purposes"
  (interactive)
  (start-process-shell-command
   "Notepad"
   "*notepad.exe*"
   (combine-and-quote-strings '("env WINEPREFIX="
                                "/home/nanjigen/.local/share/wineprefixes/supermemo18"
                                " wine "
                                "notepad.exe"
                                "") "\"")))

#+end_src

#+begin_src elisp
(process-list)
#+end_src

#+RESULTS:
| SuperMemo18 | *Guix Internal REPL* | Guile REPL | vterm | *bash-completion* | XELB | epdfinfo | server |

#+begin_src elisp
;; (process-command (get-process "SuperMemo18"))
;; (alist-get 'comm (process-attributes
;;                   (process-id (get-process "SuperMemo18"))))
;; (process-id (get-process "SuperMemo18"))
;; (get-process "SuperMemo18")
;; (process-name (get-process "SuperMemo18"))
;; (let* ((child-procs (alist-get 'comm (process-attributes 3335)))
;;        ()))
(process-attributes (process-id (get-process "SuperMemo18")))

;; (exwm--update-class 3335)
;; (exwm--id->buffer 8178896)
#+end_src

#+RESULTS:
: ((args . /home/nanjigen/.local/share/wineprefixes/supermemo18/drive_c/SuperMemo/sm18.exe) (pmem . 0.9888432805055687) (pcpu . 0.5553476355470778) (etime 0 828 310000 0) (rss . 97864) (vsize . 2725560) (start 24910 33423 939463 133000) (thcount . 4) (nice . 0) (pri . 20) (ctime 0 0 0 0) (cstime 0 0 0 0) (cutime 0 0 0 0) (time 0 4 600000 0) (stime 0 1 450000 0) (utime 0 3 150000 0) (cmajflt . 0) (cminflt . 228) (majflt . 16202) (minflt . 68015) (tpgid . 3806) (ttname . /dev/pts0) (sess . 3806) (pgrp . 3806) (ppid . 22545) (state . S) (comm . sm18.exe) (group . users) (egid . 998) (user . nanjigen) (euid . 1000))

#+begin_src sh
guix install dotnet@3
#+end_src

#+RESULTS:

#+begin_src sh
# xprop -id 3806
# pgrep sm18.exe
# xdotool search --pid 3806
# xdotool search --pid 3335 -- set_window --class sm18
xdotool search --name home

#+end_src
#+RESULTS:

81788961

** sm yasnippet
:PROPERTIES:
:CREATED:  [2021-01-04 Mon 15:52]
:ID:       9fd2197d-3730-458d-ad94-c90d7309d355
:END:

#+begin_src yasnippet
# -*- mode: snippet -*-
# name: org-pdftools-sm-reference
# key: pdf-ref
# --

#SuperMemoReference
#Title:
#Author:
#Date: Imported on Dec 28, 2020, 00:00:00
#Source: (org-ref) bibtex?
#Link: pdf:
#Comment:
#Article: 40:
#Concept group: Root: neruon (1: neuron)
#+end_src

** TODO Add to sma-cli as reference
:PROPERTIES:
:CREATED:  [2022-07-07 Thu 08:54]
:ID:       b25565e2-8c17-40b0-9965-9c6080dbdfe5
:END:

https://stackoverflow.com/questions/64702791/running-a-dotnet-dll-from-process-in-a-dotnet-application-on-linux

** TODO Buffer display, for SM?
:PROPERTIES:
:CREATED:  [2022-07-07 Thu 08:54]
:ID:       4c55be0e-9a24-4e71-b69a-da543d0817dd
:END:
https://github.com/astoff/comint-mime

** TODO Send uuid entry as transclusion
** org-brain integration
:PROPERTIES:
:CREATED:  [2021-01-15 Fri 19:51]
:ID:       c53811c9-1ada-4958-9389-5b823a811479
:END:

#+begin_src elisp
(org-brain-open-resource (org-brain-entry-at-pt t))
#+end_src

** org-noter integration
:PROPERTIES:
:CREATED:  [2021-01-19 Tue 16:27]
:ID:       6f30757e-e54b-4e7b-a43f-1443c1090730
:END:

#+begin_src elisp
;;; lang/org-private/+ir.el -*- lexical-binding: t; -*-
#+end_src

This should be a minor mode as is done with [[file:~/.emacs.d/.local/straight/repos/org-noter/org-noter.el::(define-minor-mode org-noter-notes-mode][org-noter]] (note that there are /2/ minor modes).
#+begin_src elisp
;; Key binds etc
(use-package! major-mode-hydra
  :config
  (major-mode-hydra-define pdf-view-mode
    (:title "Incremental Reading Options")
    ("Reading qeue"
     ;; There should a hydra that moves to the next item in the reading que
     (("n" evil-collection-pdf-view-next-line-or-next-page "next")
      ("p" evil-collection-pdf-view-previous-line-or-previous-page "previous"))
     "Test"
     (("s" isearch-forward "search"))
     ;; "Priority"
     ;; Priority setting options
     ;;TODO Should define some functions
     "Drill"
     (("d" nanjigen/org-drill-in-ir-dir "org-drill items")
      ("D" org-drill-resume "Resume last org-drill"))
     )))

  (pretty-hydra-define ir-hydra
    (:color blue :title "Incremental Reading")
    ("Reading que"
     ;; There should a hydra that moves to the next item in the reading que
     (("n" evil-collection-pdf-view-next-line-or-next-page "next")
      ("p" evil-collection-pdf-view-previous-line-or-previous-page "previous"))
     "org-noter"
     (("o" follow-noter-page-link "follow org-pdftools link")
      ;; Should this be a function in a specific workspace?
      ("N" org-noter "Start org-noter session")
      ("S" org-noter-pdftools-create-skeleton "Create org-noter outline"))
     ;; "Priority"
     ;; Priority setting options
     ;;TODO Should define some functions
     "Drill"
     (("d" nanjigen/org-drill-in-ir-dir "org-drill items")
      ("D" org-drill-resume "Resume last org-drill"))
     ))


(map! :localleader
      :map pdf-view-mode-map
          :desc "Insert to Org" "h" 'nanjigen/org-noter-highlight-drill)

#+end_src

The below function is an addition to [[file:~/.emacs.d/.local/straight/repos/org-noter/org-noter.el::defun org-noter-insert-note-toggle-no-questions (][org-noter-insert-note-no-questions]], possibly to insure that the ~org-pdftools~ link gets inserted correctly.
#+begin_src elisp
  ;; Add a function to ensure precise note is inserted
  (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
    (interactive "P")
    (org-noter--with-valid-session
     (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                   (not org-noter-insert-note-no-questions)
                                                 org-noter-insert-note-no-questions))
           (org-pdftools-use-isearch-link t)
           (org-pdftools-use-freestyle-annot t))
       (org-noter-insert-note (org-noter--get-precise-info)))))

#+end_src

We want items inserted with the following syntax:
#+begin_example org-mode
,** [[cite:laufer2001][10]] annot-2-0 | descriptive text                  :extract:
#+end_example

The =:extract:= tag will allow us to target those inserted headers with ~elisp~ code, and differentiate extraction headers from skeleton entries. The =cite:= syntax activates ~org-ref~ functions which may be used programmatically down the line. The "annot-2-0" is a reference to the ~org-pdftools~ link syntax -
(:NOTER_PAGE: [[pdf:~/Documents/PDF/laufer2001.pdf::2++0.00;;annot-2-0]] in this case).
The first numeral, 2, is a reference to the internal page number of the source pdf. With some text-munging we can procure the page number of the pdf for the given extract and potentially insert that into an org-buffer when writing to aid with citing: [[cite:laufer2001][2]].

#+begin_src elisp
(org-ref-insert-link nil)
(funcall org-ref-insert-cite-function)
(defun nanjigen/org-pdftools-annot-id ()
  "get 'annot' id from 'NOTER_PAGE' property"
  (interactive)
  (let* ((id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
         (id-clean (s-chop-suffix "]]" id)))
    (insert (format "%s" id-clean))))

(org-toggle-tag "extract")
#+end_src

#+begin_src elisp
(when (and org-noter-insert-selected-text-inside-note selected-text) (insert (concat "#+begin_quote\n" selected-text "\n#+end_quote")))

(defun org-noter-insert-note-content ()
  (interactive)
  (progn (setq currenb (buffer-name))
         (set-buffer currenb)
         (org-noter-insert-note)
         ;; (org-noter-quote)
))

(fset 'org-noter-quote
      (kmacro-lambda-form [?  ?: ?j ?o ?i ?n ?e ?  backspace backspace return ?V ?  ?i ?s ?q ?u ?o ?t ?e return escape ?\{ ?\{ ?d ?d] 0 "%d"))

(setq org-noter-default-heading-title )
#+end_src

#+begin_src elisp
(defun org-noter-insert-selected-text-as-content (&optional precise-info)
  "Insert note associated with the current location.

This command will prompt for a title of the note and then insert
it in the notes buffer. When the input is empty, a title based on
`org-noter-default-heading-title' will be generated.

If there are other notes related to the current location, the
prompt will also suggest them. Depending on the value of the
variable `org-noter-closest-tipping-point', it may also
suggest the closest previous note.

PRECISE-INFO makes the new note associated with a more
specific location (see `org-noter-insert-precise-note' for more
info).

When you insert into an existing note and have text selected on
the document buffer, the variable `org-noter-insert-selected-text-inside-note'
defines if the text should be inserted inside the note."
  (interactive)
  (org-noter--with-valid-session
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text
           (cond
            ((eq (org-noter--session-doc-mode session) 'pdf-view-mode)
             (when (pdf-view-active-region-p)
               (mapconcat 'identity (pdf-view-active-region-text) ? )))

            ((eq (org-noter--session-doc-mode session) 'nov-mode)
             (when (region-active-p)
               (buffer-substring-no-properties (mark) (point))))))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (view-info (org-noter--get-view-info (org-noter--get-current-view) location)))

     (let ((inhibit-quit t))
       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((point (point))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection default default-begin title selection
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           (cond
            ;; NOTE(nox): Both precise and without questions will create new notes
            ((or precise-info force-new)
             (setq default (and selected-text (replace-regexp-in-string "\n" " " selected-text))))
            (org-noter-insert-note-no-questions)
            (t
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons)))
                     (begin (org-element-property :begin (car note-cons))))
                 (push (cons display note-cons) collection)
                 (when (and (>= point begin) (> begin (or default-begin 0)))
                   (setq default display
                         default-begin begin))))))

           (setq collection (nreverse collection)
                 title (if org-noter-insert-note-no-questions
                           default
                         (completing-read "Note: " collection nil nil nil nil default))
                 selection (unless org-noter-insert-note-no-questions (cdr (assoc title collection))))


             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
                 (setq title "test")
                 ;; (setq title (replace-regexp-in-string (regexp-quote "$p$") (number-to-string (car location))
                 ;;                                       org-noter-default-heading-title))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous window.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session)))))))))
#+end_src

#+name: selected text to content
#+begin_src elisp
(defun org-noter-insert-selected-text-as-content (&optional precise-info)
  "Insert note associated with the current location.

This command will prompt for a title of the note and then insert
it in the notes buffer. When the input is empty, a title based on
`org-noter-default-heading-title' will be generated.

If there are other notes related to the current location, the
prompt will also suggest them. Depending on the value of the
variable `org-noter-closest-tipping-point', it may also
suggest the closest previous note.

PRECISE-INFO makes the new note associated with a more
specific location (see `org-noter-insert-precise-note' for more
info).

When you insert into an existing note and have text selected on
the document buffer, the variable `org-noter-insert-selected-text-inside-note'
defines if the text should be inserted inside the note."
  (interactive)
  (org-noter--with-valid-session
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text
           (cond
            ((eq (org-noter--session-doc-mode session) 'pdf-view-mode)
             (when (pdf-view-active-region-p)
               (mapconcat 'identity (pdf-view-active-region-text) ? )))

            ((eq (org-noter--session-doc-mode session) 'nov-mode)
             (when (region-active-p)
               (buffer-substring-no-properties (mark) (point))))))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (view-info (org-noter--get-view-info (org-noter--get-current-view) location)))

     (let ((inhibit-quit t))
       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((point (point))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection default default-begin title selection
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           (cond
            ;; NOTE(nox): Both precise and without questions will create new notes
            ((or precise-info force-new)
             (setq default (and selected-text (replace-regexp-in-string "\n" " " selected-text))))
            (org-noter-insert-note-no-questions)
            (t
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons)))
                     (begin (org-element-property :begin (car note-cons))))
                 (push (cons display note-cons) collection)
                 (when (and (>= point begin) (> begin (or default-begin 0)))
                   (setq default display
                         default-begin begin))))))

           (setq collection (nreverse collection)
                 title (if org-noter-insert-note-no-questions
                           default
                         (completing-read "Note: " collection nil nil nil nil default))
                 selection (unless org-noter-insert-note-no-questions (cdr (assoc title collection))))

           (if selection
               ;; NOTE(nox): Inserting on an existing note

               (let* ((note (car selection))
                      (insert-before-element (cdr selection))
                      (has-content
                       (eq (org-element-map (org-element-contents note) org-element-all-elements
                             (lambda (element)
                               (if (org-noter--check-location-property element)
                                   'stop
                                 (not (memq (org-element-type element) '(section property-drawer)))))
                             nil t)
                           t)))
                 (when has-content (setq empty-lines-number 2))
                 (if insert-before-element
                     (goto-char (org-element-property :begin insert-before-element))
                   (goto-char (org-element-property :end note)))


                 (if (org-at-heading-p)
                     (progn
                       (org-N-empty-lines-before-current empty-lines-number)
                       (forward-line -1))
                   (unless (bolp) (insert "\n"))
                   (org-N-empty-lines-before-current (1- empty-lines-number)))

                 (when (and org-noter-insert-selected-text-inside-note selected-text) (insert selected-text)))
                 ;; (insert selected-text))

             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
               (when (zerop (length title))
                 (setq title (replace-regexp-in-string (regexp-quote "$p$") (number-to-string (car location))
                                                       org-noter-default-heading-title)))

               (if reference-element-cons
                   (progn
                     (cond
                      ((eq (car reference-element-cons) 'before)
                       (goto-char (org-element-property :begin (cdr reference-element-cons))))
                      ((eq (car reference-element-cons) 'after)
                       (goto-char (org-element-property :end (cdr reference-element-cons)))))

                     ;; NOTE(nox): This is here to make the automatic "should insert blank" work better.
                     (when (org-at-heading-p) (backward-char))

                     (setq level (org-element-property :level (cdr reference-element-cons))))

                 (goto-char (org-element-map contents 'section
                              (lambda (section) (org-element-property :end section))
                              nil t org-element-all-elements))
                 (setq level (1+ (org-element-property :level ast))))

               ;; NOTE(nox): This is needed to insert in the right place
               (outline-show-entry)
               (org-noter--insert-heading level title empty-lines-number location)
               (when (org-noter--session-hide-other session) (org-overview))

               (setf (org-noter--session-num-notes-in-view session)
                     (1+ (org-noter--session-num-notes-in-view session)))))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous windo.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session))))))))
#+end_src

*** old org-noter code                                              :extract:
:PROPERTIES:
:CREATED:  [2021-01-19 Tue 17:18]
:ID:       52a04c78-0f21-46af-80af-18a43cbea9f4
:header-args: :tangle ~/.doom.d/modules/lang/org-private/+ir.el :noweb yes
:END:

#+begin_src elisp
;;; lang/org-private/+ir.el -*- lexical-binding: t; -*-
#+end_src

The actual function to extract to point
#+begin_src elisp
(defun nanjigen/org-noter-extract ()
  "Extract highlighted text into org-noter buffer as org-drill item"
  (interactive)
  ;; (org-back-to-heading)
  (save-window-excursion
  ;; Now I need to move the header text (which is the extracted pdf text) into the body
    (progn
      (nanjigen/move-headline-to-contents)
      (org-toggle-tag "extract"))))
#+end_src

#+begin_src elisp
(defun nanjigen/open-link-clipboard ()
  (interactive)
  (let ((link (substring-no-properties (x-get-selection 'CLIPBOARD 'STRING))))
    (org-link-open-from-string link)))

;; (org-noter "[[pdf:/home/vrika/Documents/PDF/books/wickedcoolshellscripts.pdf::1]]")
;; (org-brain-open-org-noter "3f0bea0e-07dd-4e48-9df7-aaeb8f1d3b8d")
#+end_src

#+RESULTS:
: nanjigen/open-link-clipboard

This is a fairly ugly hack. My ultimate intention is to use modified org-noter code.
#+begin_src elisp
(defun nanjigen/move-headline-to-contents ()
  "Move extracted PDF text to body of subtree"
  (interactive)
  ;; (let ((origin-element-type (org-element-type (org-element-at-point))))
  ;;   (if (string-equal "property-drawer" origin-element-type)
  ;;       (evil-insert-newline-below)))
  (progn
    ;; (with-selected-window (org-noter--get-notes-window)
    ;;   (evil-insert-newline-below))
    (org-noter-insert-note-toggle-no-questions)
    (org-back-to-heading)
    (org-toggle-tag "extract")
    (let* ((parent
            (save-excursion
              (org-backward-element)
              (org-element-property :title (org-element-at-point))))
           (headline (org-element-at-point))
           (title (org-element-property :title headline))
           (property-end (org-element-property :contents-end headline))
           ;; (property (org-element-at-point (goto-char property-pos)))
           (indent (org-element-property :level headline))
           (title-start (+ indent (org-element-property :begin headline)))
           (title-end (- (org-element-property :contents-begin headline) 1))
           (annot-id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
           (annot-id-clean (s-chop-suffix "]]" annot-id))
           (org-uuid (org-entry-get nil "ID"))
           (annot-link (format "[[brain:%s][%s]]" org-uuid annot-id-clean))
           (cite-page (with-selected-window (org-noter--get-doc-window)
                        (format "%s"
                                (eval '(nth (1- (pdf-view-current-page))
                                            (pdf-cache-pagelabels))))))
           (cite (file-name-sans-extension (file-name-nondirectory (buffer-file-name)))))
      ;; (when (eq 'property-drawer (car property))
      ;; (goto-char (org-element-property :end property)))
      (goto-char property-end)
      (insert title)
      (delete-region title-start title-end)
      (goto-char title-start)
      ;;HACK use logic to identify if parent is an org-noter-outline headline
      ;; and then indent with org-mode code, not a hacky *!
      (insert (format " [[cite:%s][p%s]] %s" cite cite-page annot-link))
      ;; (save-excursion
        ;; (if (not (string-prefix-p "cite" parent))
        ;;     ;; (nanjigen/org-move-to-sibling)
        ;;     (nanjigen/org-move-to-extreme)
        ;;   )
      ;;
      ;;     (insert (format " cite:%s %s" cite id-clean))
      ;;   (insert (format "* cite:%s %s" cite id-clean)))
      (org-back-to-heading))))
#+end_src

#+RESULTS:
: nanjigen/move-headline-to-contents

Attempting to move to max point in tree from https://emacs.stackexchange.com/questions/43651/moving-a-subtree-to-the-top-or-bottom-of-its-parent/43662#43662
#+begin_src elisp
(defun nanjigen/org-move-to-extreme ()
  "Move current org subtree to the start of its parent."
  (interactive)
  (condition-case err
      (while t
        (funcall 'org-move-subtree-up)))
    (user-error
     (let ((err-msg (cadr err)))
       (unless (string-match "Cannot move past superior level or buffer limit" err-msg)
         (signal 'user-error (list err-msg))))))
#+end_src

#+begin_src elisp
(defun nanjigen/org-move-to-sibling ()
  "Move extracted org subtree under its 'cite:' sibling."
  (interactive)
  (setq parent (nanjigen/org-get-above-headline))
  (while (not (string-prefix-p "cite" parent))
     (funcall 'org-move-subtree-up)
     (setq parent (nanjigen/org-get-above-headline))))
#+end_src

#+begin_src elisp
(defun nanjigen/org-get-above-headline ()
"Get the headline entry of above parent/sibling as text"
(save-excursion
  (org-backward-element)
  (org-element-property :title (org-element-at-point))))
#+end_src

#+RESULTS:
: JK-org-move-to-extreme

#+begin_src elisp
(defun nanjigen/chopper ()
  "get 'annot' id from 'NOTER_PAGE' property"
  (interactive)
  (let* ((id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
         (id-clean (s-chop-suffix "]]" id)))
    (insert (format "%s" id-clean))))

(defun nanjigen/delete-headline ()
  "delete the original title of text extracted with
(org-noter-insert-note-toggle-no-questions)"
  (interactive)
  (let* ((headline (org-element-at-point))
         (title-start (org-element-property :contents-begin headline))
         (title-end (org-element-property :end headline)))
    (delete-region title-start title-end)))

;; Functions for capturing from org noter
  (defun nanjigen/get-noter-link ()
    "return PROPERTY value of pdftools link"
    (interactive)
    (let ((linkStr (org-entry-get nil "NOTER_PAGE")))
      (insert linkStr)))

  ;;https://emacs.stackexchange.com/questions/32283/how-to-capture-and-link-code-comments-as-org-agenda-items
  (defun capture-noter-link ()
    "insert PROPERTY value of pdftools link"
    (interactive)
    (let ((linkStr
            (save-excursion
              (save-window-excursion
                (switch-to-buffer (plist-get org-capture-plist :original-buffer))
                (car (org-get-outline-path)))
              )))
      ))


  (defun insert-key (&optional p)
    "insert header as key value of org-brain header"
    ;; (unless p (setq p "NOTER_PAGE"))
    ;; (message "property passed is: %s" p)
    (interactive)
    (let ((pvalue
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved header (key) is: %s" (car (org-get-outline-path (point) p)))
              (car (org-get-outline-path (point) p))
              )))
      pvalue))


  (defun key-to-header (&optional p)
    "insert header in org-capture target file as key value of org-brain header"
    ;; (unless p (setq p "NOTER_PAGE"))
    ;; (message "property passed is: %s" p)
    (interactive)
    (let ((heading
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved header (key) is: %s" (car (org-get-outline-path (point) p)))
              (car (org-get-outline-path (point) p))
              )))
      (goto-char (org-find-exact-headline-in-buffer "IR Cards"))
      (unless (search-forward (format "** %s" heading) nil t)
        (org-end-of-subtree)
        (insert (format "\n** %s" heading))
        )))

  (defun insert-property (&optional p)
    "insert PROPERTY value of pdftools link"
    (interactive)
    (unless p (setq p "NOTER_PAGE"))
    (message "property passed is: %s" p)
    (let ((pvalue
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved property is: %s" (org-entry-get (point) p))
              (org-entry-get (point) p)
              )))
      pvalue))

  (defun follow-noter-page-link ()
    "return PROPERTY value of pdftools link and follow in other-window"
    (interactive)
    ;; (run-with-timer 3 nil (lambda ()
      ;; TODO switch-to-buffer?
    (let ((linkStr (org-entry-get nil "NOTER_PAGE")))
      (if (> (length (window-list)) 1)
          (other-window 1)
        ;; (balance-windows)
          ;; (switch-to-buffer-other-window)
        (split-window-right))
      (org-link-open-from-string linkStr)))
;;
#+end_src

*** TODO Automatic screenshots in org-noter with Flameshot
:PROPERTIES:
:CREATED:  [2021-06-02 Wed 17:04]
:ID:       1b6ec7b5-1957-4b53-ad71-1f58f2b99fac
:END:

#+begin_src elisp
(use-package! org-download
  :config
  (setq org-download-method 'attach))

(defun org-noter-insert-image-slice-note ()
  (interactive)
  (async-start (shell-command "flameshot gui")
               (progn
                 (switch-to-buffer-other-window
                  (window-buffer (org-noter--get-notes-window)))
                 ;; (defmacro org-noter--with-selected-notes-window ...)
                 (async-start (org-noter-insert-note)
                              (org-download-clipboard)))))

(define-key org-noter-doc-mode-map (kbd "Y") 'org-noter-insert-image-slice-note)
#+end_src

*** old org-drill code
:PROPERTIES:
:CREATED:  [2021-01-20 Wed 13:58]
:ID:       7a12e649-f742-443e-bf42-6de953eb9752
:END:

#+begin_src elisp
;; This is to initiate drill from anywhere
;; Have next PDF fire off instead if all done?
(defun nanjigen/org-drill-in-ir-dir ()
  (interactive)
  (with-current-buffer (find-file-noselect "~/org/article-notes/article-index.org")
    (org-drill)))


;; (advice-add 'org-drill-reschedule :after-until #'follow-noter-page-link)
;; (advice-add 'org-drill-entry-p :after #'follow-noter-page-link)
;; (advice-add '(org-drill-entries (session-done)) :after #'follow-noter-page-link)
;; (advice-add 'org-drill-goto-entry :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-simple-card :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-default-answer :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-two-sided-card :after #'follow-noter-page-link)
;; (advice-add 'org-drill--edit-key :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete-rtn :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-quit  :after #'follow-noter-page-link)
;; (add-function :after ('org-drill-response-edit) #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete :after #'follow-noter-page-link)
(advice-add 'org-drill-response-edit :after #'follow-noter-page-link)
(advice-add 'org-drill-response-edit :after-while #'follow-noter-page-link)
(advice-add 'org-drill-response-quit  :after #'follow-noter-page-link)
;; (advice-add 'org-drill--edit-key :after #'follow-noter-page-link)


;; This triggers the function but not at the right time
;; (add-hook 'org-drill-display-answer-hook #'follow-noter-page-link)
#+end_src

* mpv integration
:PROPERTIES:
:CREATED:  [2021-01-14 Thu 20:03]
:ID:       d3b44770-6bb2-4675-b451-3f388e0cb6da
:END:

An alternative to scripting with =lua= would be using the =fennel= language.

** NEXT Hide modeline for mpv buffers                              :@computer:
:PROPERTIES:
:CREATED:  [2022-07-07 Thu 08:54]
:ID:       33fe2236-8cab-4ff2-8a6d-9ed0a7184ae1
:END:
(maybe just when calling mpv from sm?)

** TODO MPV Emacs open view metadata
Open metadata in a buffer?
** TODO Embed fennel in mpv lua module
:PROPERTIES:
:CREATED:  [2021-08-14 Sat 12:34]
:ID:       34ae3659-6881-476b-a132-0a3863ad8064
:END:

https://gitlab.com/technomancy/fennel-mode/-/blob/master/Readme.md
https://fennel-lang.org/setup#embedding-fennel

** mpv input.conf
:PROPERTIES:
:CREATED:  [2021-01-31 Sun 11:17]
:ID:       8c4df6c5-9b2b-4352-a1bc-31a11e4fd1b9
:END:

#+begin_src lua :tangle ~/.config/mpv/input.conf
# mpv keybindings
#
# Location of user-defined bindings: ~/.config/mpv/input.conf
#
# Lines starting with # are comments. Use SHARP to assign the # key.
# Copy this file and uncomment and edit the bindings you want to change.
#
# List of commands and further details: DOCS/man/input.rst
# List of special keys: --input-keylist
# Keybindings testing mode: mpv --input-test --force-window --idle
#
# Use 'ignore' to unbind a key fully (e.g. 'ctrl+a ignore').
#
# Strings need to be quoted and escaped:
#   KEY show-text "This is a single backslash: \\ and a quote: \" !"
#
# You can use modifier-key combinations like Shift+Left or Ctrl+Alt+x with
# the modifiers Shift, Ctrl, Alt and Meta (may not work on the terminal).
#
# The default keybindings are hardcoded into the mpv binary.
# You can disable them completely with: --no-input-default-bindings

# Developer note:
# On compilation, this file is baked into the mpv binary, and all lines are
# uncommented (unless '#' is followed by a space) - thus this file defines the
# default key bindings.

# If this is enabled, treat all the following bindings as default.
#default-bindings start

#MBTN_LEFT     ignore              # don't do anything
#MBTN_LEFT_DBL cycle fullscreen    # toggle fullscreen on/off
#MBTN_RIGHT    cycle pause         # toggle pause on/off
#MBTN_BACK     playlist-prev
#MBTN_FORWARD  playlist-next

# Mouse wheels, touchpad or other input devices that have axes
# if the input devices supports precise scrolling it will also scale the
# numeric value accordingly
#WHEEL_UP      seek 10
#WHEEL_DOWN    seek -10
#WHEEL_LEFT    add volume -2
#WHEEL_RIGHT   add volume 2

## Seek units are in seconds, but note that these are limited by keyframes
RIGHT seek  5
LEFT  seek -5
UP    seek  60
DOWN  seek -60
# Do smaller, always exact (non-keyframe-limited), seeks with Shift.
# Don't show them on the OSD (no-osd).
Shift+RIGHT no-osd seek  1 exact
Shift+LEFT  no-osd seek -1 exact
Shift+UP    no-osd seek  5 exact
Shift+DOWN  no-osd seek -5 exact
# Skip to previous/next subtitle (subject to some restrictions; see manpage)
Ctrl+LEFT   no-osd sub-seek -1
Ctrl+RIGHT  no-osd sub-seek  1
# Adjust timing to previous/next subtitle
Ctrl+Shift+LEFT sub-step -1
Ctrl+Shift+RIGHT sub-step 1
# Move video rectangle
Alt+left  add video-pan-x  0.1
Alt+right add video-pan-x -0.1
Alt+up    add video-pan-y  0.1
Alt+down  add video-pan-y -0.1
# Zoom/unzoom video
Alt++     add video-zoom   0.1
Alt+-     add video-zoom  -0.1
# Reset video zoom/pan settings
#Alt+BS set video-zoom 0 ; set video-pan-x 0 ; set video-pan-y 0
PGUP add chapter 1                     # skip to next chapter
PGDWN add chapter -1                   # skip to previous chapter
#Shift+PGUP seek 600
#Shift+PGDWN seek -600
[ multiply speed 1/1.1                 # scale playback speed
] multiply speed 1.1
{ multiply speed 0.5
} multiply speed 2.0
BS set speed 1.0                       # reset speed to normal
Shift+BS revert-seek                   # undo previous (or marked) seek
Shift+Ctrl+BS revert-seek mark         # mark position for revert-seek
q quit
#Q quit-watch-later
#q {encode} quit 4
ESC set fullscreen no
#ESC {encode} quit 4
#p cycle pause                          # toggle pause/playback mode
. frame-step                           # advance one frame and pause
, frame-back-step                      # go back by one frame and pause
SPACE cycle pause
#> playlist-next                        # skip to next file
#ENTER playlist-next                    # skip to next file
#< playlist-prev                        # skip to previous file
O no-osd cycle-values osd-level 3 1    # cycle through OSD mode
o show-progress
P show-progress
i script-binding stats/display-stats
I script-binding stats/display-stats-toggle
` script-binding console/enable
z add sub-delay -0.1                   # subtract 100 ms delay from subs
Z add sub-delay +0.1                   # add
x add sub-delay +0.1                   # same as previous binding (discouraged)
#ctrl++ add audio-delay 0.100           # this changes audio/video sync
#ctrl+- add audio-delay -0.100
m cycle mute
1 add contrast -1
2 add contrast 1
3 add brightness -1
4 add brightness 1
5 add gamma -1
6 add gamma 1
7 add saturation -1
8 add saturation 1
Alt+0 set window-scale 0.5
Alt+1 set window-scale 1.0
Alt+2 set window-scale 2.0
# toggle deinterlacer (automatically inserts or removes required filter)
d cycle deinterlace
r add sub-pos -1                       # move subtitles up
R add sub-pos +1                       #                down
t add sub-pos +1                       # same as previous binding (discouraged)
v cycle sub-visibility
# stretch SSA/ASS subtitles with anamorphic videos to match historical
V cycle sub-ass-vsfilter-aspect-compat
# switch between applying no style overrides to SSA/ASS subtitles, and
# overriding them almost completely with the normal subtitle style
u cycle-values sub-ass-override "force" "no"
j cycle sub                            # cycle through subtitles
J cycle sub down                       # ...backwards
#SHARP cycle audio                      # switch audio streams
#_ cycle video
#T cycle ontop                          # toggle video window ontop of other windows
f cycle fullscreen                     # toggle fullscreen
s screenshot                           # take a screenshot
S screenshot video                     # ...without subtitles
Ctrl+s screenshot window               # ...with subtitles and OSD, and scaled
Alt+s screenshot each-frame            # automatically screenshot every frame
w add panscan -0.1                     # zoom out with -panscan 0 -fs
W add panscan +0.1                     #      in
e add panscan +0.1                     # same as previous binding (discouraged)
# cycle video aspect ratios; "-1" is the container aspect
A cycle-values video-aspect-override "16:9" "4:3" "2.35:1" "-1"
#POWER quit
#PLAY cycle pause
#PAUSE cycle pause
#PLAYPAUSE cycle pause
#PLAYONLY set pause no
#PAUSEONLY set pause yes
#STOP quit
#FORWARD seek 60
#REWIND seek -60
#NEXT playlist-next
#PREV playlist-prev
#VOLUME_UP add volume 2
#VOLUME_DOWN add volume -2
#MUTE cycle mute
#CLOSE_WIN quit
#CLOSE_WIN {encode} quit 4
#E cycle edition                        # next edition
l ab-loop                              # Set/clear A-B loop points
L cycle-values loop-file "inf" "no"    # toggle infinite looping
#ctrl+c quit 4
DEL script-binding osc/visibility      # cycle OSC display
#ctrl+h cycle-values hwdec "auto" "no"  # cycle hardware decoding
F8 show_text ${playlist}               # show playlist
F9 show_text ${track-list}             # show list of audio/sub streams

#
# Legacy bindings (may or may not be removed in the future)
#
#! add chapter -1                       # skip to previous chapter
#@ add chapter 1                        #         next

#
# Not assigned by default
# (not an exhaustive list of unbound commands)
#

# ? add sub-scale +0.1                  # increase subtitle font size
# ? add sub-scale -0.1                  # decrease subtitle font size
# ? cycle angle                         # switch DVD/Bluray angle
# ? cycle sub-forced-only               # toggle DVD forced subs
# ? cycle program                       # cycle transport stream programs
# ? stop                                # stop playback (quit or enter idle mode)

CTRL+SHIFT+p script-message chapterlist

# g run "home/nanjigen/.config/mpv/scripts/giffer" "${path}" "/home/nanjigen/Videos/${filename/no-ext} ${=ab-loop-a}.gif" "${=ab-loop-a}" "${=ab-loop-b}"
# h run "home/nanjigen/.config/mpv/scripts/giffer" "${path}" "/home/nanjigen/Videos" "${=ab-loop-a}" "${=ab-loop-b}"

#+end_src

* TODO Run sm in a container
:PROPERTIES:
:CREATED:  [2022-07-07 Thu 09:36]
:ID:       47d7af06-7311-4e0b-a374-f2830185c009
:END:
Should the sm docker be a separate repo?
* SM in a VM and RPC
:PROPERTIES:
:CREATED:  [2020-12-11 Fri 21:15]
:ID:       fafd87f0-c7c8-467d-861c-d0fc634d9893
:END:

* AHK
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       8d766356-bb00-4536-8974-6906b6c2837f
:END:

A good guide for ahk under linux https://code.google.com/archive/p/winetricks/wikis/AutoHotkey.wiki
#+begin_src ahk :tangle ~/.scripts/ahk/activate.verb :mkdirp yes
w_metadata activate apps \
title="Hello, Autohotkey"

load_activate()
{
w_ahk_do "
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
run, notepad.exe
WinWait, Untitled - Notepad
;ControlSend, lol, Test, ahk_class TElWind
;ControlSend, Test2, {v}, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;j::
;WinActivate, ahk_exe sm18.exe
;WinGetActiveTitle, Title
;WinGetClass, Var, A
;MsgBox ahk_class %Var%
;MsgBox, The active window is "%Title%".
send, l
;return
"
}
#+end_src

Finding the class of a window
#+begin_src ahk :tangle ~/.scripts/ahk/class.verb :mkdirp yes
w_metadata class apps \
title="Hello, Autohotkey"

load_class()
{
w_ahk_do "
j::
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;WinActivate, ahk_class sm18.exe
WinGetActiveTitle, Var
;WinGetClass, Var, A
;ControlGet, Var, A
;MsgBox ahk_class %Var%
MsgBox, The active window is "%Var%".
;send, l
return
"
}
#+end_src

Testing some sending code
#+begin_src ahk :tangle ~/.scripts/ahk/send.verb :mkdirp yes
w_metadata send apps \
title="Hello, Autohotkey"

load_send()
{
w_ahk_do "
;j::
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;#IfWinActive, ahk_class, Notepad
;ControlSend, Edit1, Test, WinTitle, Untitled - Notepad
;ControlSend, Edit1, Test, Untitled - Notepad
ControlSend, Edit1, Test, home
;WinGetActiveTitle, Var
;WinGetClass, Var, A
;MsgBox ahk_class %Var%
;MsgBox, The active window is "%Var%".
;send, l
;return
"
}
#+end_src

This works well for copying the element path
#+begin_src ahk :tangle ~/.scripts/ahk/senda.verb :mkdirp yes
w_metadata senda apps \
title="Hello, Autohotkey"

load_senda()
{
w_ahk_do "
#NoEnv  ; Recommended for performance and compatibility with futur§e AutoHotkey releases.
; #Warn  ; Enable warnings to assist with detecting common errors.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
;SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.
SetTitleMatchMode,2
;WinActivate, ahk_exe sm18.exe
;WinWaitActive, ahk_exe sm18.exe
;WinActivate, ahk_class TElWind
;WinWaitActive, WinTitle Untitled - Notepad
#IfWinActive, ahk_class TElWind

::sm-get-path::
send, +{F10}
;sleep,5
send, f
;sleep,5
send, c
;send, ^a
"
}
#+end_src
z:\\home\\vrika\\documents\\sm\\neuron\\elements\\16\\168.HTM
z:\home\vrika\documents\sm\neuron\elements\16\168.HTM
file:/home/vrika/Documents/SM/neuron/elements/16/167.HTM

Change windows path to unix:

#+begin_src elisp
;; (defun my-translate-winpath ()
  ;; (interactive)
  ;; "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (shell-command-to-string (format "~/.scripts/winpath.sh %s" path)))
#+end_src

#+begin_src elisp
(defun my-translate-winpath ()
  (interactive)
  (progn
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
  (shell-command "xclip -sel clip -o")
  (shell-command "xdotool sleep 0.2 key --delay 50 Shift+F10+f+c")
;; (gui--selection-value-internal 'CLIPBOARD)
  (setq sm-path (gui--selection-value-internal 'CLIPBOARD))
    (let* ((path1 (s-chop-prefix "z:" sm-path))
           (nixpath (s-replace "\\" "/" path1))
           (docpath (s-replace "documents" "Documents" nixpath))
           (finpath (s-replace "sm" "SM" docpath)))
      (setq sm-path-nix finpath))))
;; (list path path2)
;; (shell-command-to-string (format "~/.scripts/winpath.sh" ))
#+end_src

#+RESULTS:
: my-translate-winpath

#+begin_src elisp
(defun sm-exwm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (my-exwm-send-string "sm-get-path ")
  (sit-for 0.3)
  (let ((path (my-translate-winpath)))
    (find-file path)))
#+end_src

#+RESULTS:
: my-translate-winpath

#+begin_src elisp
(defun my-exwm-send-string (string)
  "Send STRING to `exwm-mode' buffer or just insert it."
  (if (eq major-mode 'exwm-mode)
      (mapc #'exwm-input--fake-key (string-to-list string))
    (insert string)))
#+end_src
z:\home\vrika\documents\sm\neuron\elements\5.HTM
#+RESULTS:
: my-exwm-send-string

#+begin_src elisp
;; (subst-char-in-string ?\ ?/ (regexp-quote "\home"))
;; (regexp-quote "^home")
;; (convert-standard-filename "z:\home\vrika\documents\sm\neuron\elements\16\168.HTM")
;; (setq windows-path (unescape-windows-path "\home\vrika"))

;; (setq windows-path1 "\home\vrika")
;; (wsl-path-convert-file-name "\home\vrika")
;; (s-replace "\\" "/" "\home")
;; (s-replace "\\" "/" windows-path)
;; (replace-regexp-in-string "\\\\" "\\\\\\\\" "\home\vrika")
;; (message windows-path1)
;; (defun unescape-windows-path (pth)
;;   ;; (interactive "*sWindows path:")
;;    (replace-regexp-in-string "\\\\" "\\\\\\\\" pth))

;; (defun paste-windows-path (pth)
;;   (interactive "*sWindows path:")
;;   (insert
;;    (replace-regexp-in-string "\\\\" "\\\\\\\\" pth)))
;; (message (current-kill 0 'do-not-move))
;; (shell-command-to-string "sed -e 's#^J:##' -e 's#\\#/#g' <<< 'test'")

(convert-standard-filename "~/Documents")
#+end_src

#+RESULTS:
: ~/Documents

#+begin_src sh :tangle ~/.scripts/winpath.sh
function winpath(){
    line=$(sed -e 's#^J:##' -e 's#\\#/#g' <<< "$1")
    echo "$line"
}
#+end_src

#+begin_src sh
#!/bin/bash
clip=$(xclip -selection c -o)
line=$(sed -e 's#^z:##' -e 's#\\#/#g' <<< "$clip")
echo "$line"
#+end_src

#+RESULTS:

#+begin_src ahk :tangle ~/.scripts/ahk/hotstring.verb :mkdirp yes
w_metadata hotstring apps \
title="Hello, Autohotkey"

load_hotstring()
{
w_ahk_do "
:*:get::get it boi
"
}
#+end_src

#+begin_src sh :dir ~/.scripts/ahk/ :session test
env WINEPREFIX=/home/vrika/.local/share/wineprefixes/supermemo18 winetricks activate.verb
#+end_src

#+RESULTS:
|                                              |               |                       |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | mkdir         | -p                    | /home/vrika/.local/share/wineprefixes |            |                                                                  |        |          |     |                |
| Using                                        | winetricks    | 20200412              | -                                   | sha256sum: | 40ff4c67804584b73d4d36153e1f64ca426d739f1790bd748f5ded0865e8cc7f | with   | wine-5.2 | and | WINEARCH=win32 |
| Executing                                    | w_do_call     | activate              |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | mkdir         | -p                    | /home/vrika/.local/share/wineprefixes |            |                                                                  |        |          |     |                |
| Executing                                    | load_activate |                       |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | wine          | x:\ahk\AutoHotkey.exe | C:\windows\Temp\activate.ahk        |            |                                                                  |        |          |     |                |
| 00b9:fixme:keyboard:X11DRV_GetKeyboardLayout | couldn't      | return                | keyboard                            | layout     | for                                                              | thread |       81 |     |                |

** Snippet
:PROPERTIES:
:CREATED:  [2020-12-01 Tue 22:38]
:ID:       e177ba0d-cfc1-41d7-bc09-4b2e3a1edef9
:END:

#+begin_src yas
# -*- mode: snippet -*-
# name: SuperMemo Ref
# key: sm-ref
# --

#SuperMemo Reference:
#Title: (org-web-tools--html-title (org-web-tools--get-first-url))
#Date: Imported on Oct 15, 2020, 18:50:29
#Source: Wikipedia
#Link: (org-web-tools--get-first-url)
#Comment: Lisp (programming language)
#Parent: 17: Programming
#Concept group: Root: neuron (1: neuron)
#+end_src

* PROJECT Write SM element parser
:PROPERTIES:
:CREATED:  [2022-07-07 Thu 08:54]
:ID:       8341129f-ed6d-4ab4-92eb-810e1f78da10
:END:
https://edicl.github.io/cl-who/
https://github.com/ndwarshuis/org-ml

** NEXT Experiment with closure XML parser
:PROPERTIES:
:CREATED:  [2022-07-07 Thu 08:54]
:ID:       6abb9b7f-0867-4278-bc3f-a2696eab1a7c
:TRIGGER:  chain-find-next(NEXT,from-current,priority-up,effort-down)
:END:
https://cxml.common-lisp.dev/index.html
https://s-xml.common-lisp.dev/

For sma

** TODO CL tidy for cleaning html
:PROPERTIES:
:CREATED:  [2022-07-07 Thu 08:54]
:ID:       3026fd51-20d1-47c6-8173-50682f710ea1
:END:
https://quickref.common-lisp.net/cl-tidy.html


** TODO Explore this web-tools fork
:PROPERTIES:
:CREATED:  [2022-07-07 Thu 08:54]
:ID:       dacfa0b3-8eac-400c-8716-b782e0238ed4
:END:
https://github.com/c1-g/org-web-tools/tree/fix-linked-images
* PROJECT sm-org
** TODO sm-org extractions as org special blocks
Maybe refs in src block header can be the git commit
